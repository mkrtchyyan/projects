--STAGING LAYER // SA
--====================
--====================

CREATE SCHEMA IF NOT EXISTS sa_online_sales;
CREATE SCHEMA IF NOT EXISTS sa_offline_sales;

--FOREIGN TABLE OFFLINE
--DROP FOREIGN TABLE IF EXISTS  sa_offline_sales.ext_offline_coffee_shop_transactions;
CREATE FOREIGN TABLE IF NOT EXISTS sa_offline_sales.ext_offline_coffee_shop_transactions (
  "SALES_ID" VARCHAR(1000),
  "EVENT_DT" VARCHAR(1000),
  "CUSTOMER_ID" VARCHAR(1000),
  "PRODUCT_ID" VARCHAR(1000),
  "STORE_ID" VARCHAR(1000),
  "STAFF_ID" VARCHAR(1000),
  "PAYMENT_ID" VARCHAR(1000),
  "QUANTITY" VARCHAR(1000),
  "LINE_ITEM_AMOUNT" VARCHAR(1000),
  "COST" VARCHAR(1000),
  "PROFIT" VARCHAR(1000),
  "PROFIT_MARGIN" VARCHAR(1000),
  "CUSTOMER_FIRST_NAME" VARCHAR(1000),
  "CUSTOMER_LAST_NAME" VARCHAR(1000),
  "CUSTOMER_COUNTRY" VARCHAR(1000),
  "LOYALTY_MEMBER" VARCHAR(1000),
  "LOYALTY_DISCOUNT" VARCHAR(1000),
  "PRODUCT_GROUP" VARCHAR(1000),
  "PRODUCT_CATEGORY" VARCHAR(1000),
  "PRODUCT_TYPE" VARCHAR(1000),
  "PRODUCT_DESC" VARCHAR(1000),
  "PROMO_FLAG" VARCHAR(1000),
  "PROMO_DISCOUNT" VARCHAR(1000),
  "BASE_PRICE" VARCHAR(1000),
  "IS_LIMITED_EDITION" VARCHAR(1000),
  "STORE_DESC" VARCHAR(1000),
  "STORE_CITY" VARCHAR(1000),
  "STORE_COUNTRY" VARCHAR(1000),
  "STORE_ADDRESS" VARCHAR(1000),
  "STORE_FLOOR_AREA" VARCHAR(1000),
  "STORE_TYPE" VARCHAR(1000),
  "MANAGER_ID" VARCHAR(1000),
  "STAFF_FIRST_NAME" VARCHAR(1000),
  "STAFF_LAST_NAME" VARCHAR(1000),
  "STAFF_JOB_DESC" VARCHAR(1000),
  "JOB_START_DT" VARCHAR(1000),
  "EMPLOYMENT_STATUS" VARCHAR(1000),
  "HOURLY_WAGE" VARCHAR(1000),
  "PAYMENT_METHOD" VARCHAR(1000),
  "PAYMENT_PROVIDER" VARCHAR(1000),
  "TRANSACTION_FEE" VARCHAR(1000),
  "IS_CONTACTLESS" VARCHAR(1000),
  "DAY_OF_WEEK" VARCHAR(1000),
  "DAY_OF_MONTH" VARCHAR(1000),
  "WEEK_ID" VARCHAR(1000),
  "MONTH_ID" VARCHAR(1000),
  "MONTH_DESC" VARCHAR(1000),
  "QUARTER_ID" VARCHAR(1000),
  "QUARTER_DESC" VARCHAR(1000),
  "YEAR_ID" VARCHAR(1000),
  "IS_WEEKEND" VARCHAR(1000)
)
SERVER csv_srv
OPTIONS (
  filename 'offline_coffee_shop_transactions_new.csv',
  format 'csv',
  header 'true'
);

--FOREIGN TABLE ONLINE
--DROP FOREIGN TABLE IF EXISTS  sa_online_sales.ext_online_coffee_shop_transactions;
CREATE FOREIGN TABLE IF NOT EXISTS sa_online_sales.ext_online_coffee_shop_transactions (
  "SALES_ID" VARCHAR(1000),
  "EVENT_DT" VARCHAR(1000),
  "CUSTOMER_ID" VARCHAR(1000),
  "PRODUCT_ID" VARCHAR(1000),
  "STORE_ID" VARCHAR(1000),
  "PAYMENT_ID" VARCHAR(1000),
  "QUANTITY" VARCHAR(1000),
  "LINE_ITEM_AMOUNT" VARCHAR(1000),
  "COST" VARCHAR(1000),
  "PROFIT" VARCHAR(1000),
  "PROFIT_MARGIN" VARCHAR(1000),
  "CUSTOMER_FIRST_NAME" VARCHAR(1000),
  "CUSTOMER_LAST_NAME" VARCHAR(1000),
  "CUSTOMER_COUNTRY" VARCHAR(1000),
  "LOYALTY_MEMBER" VARCHAR(1000),
  "LOYALTY_DISCOUNT" VARCHAR(1000),
  "SIGNUP_DT" VARCHAR(1000),
  "GENDER" VARCHAR(1000),
  "BIRTH_YEAR" VARCHAR(1000),
  "PRODUCT_GROUP" VARCHAR(1000),
  "PRODUCT_CATEGORY" VARCHAR(1000),
  "PRODUCT_TYPE" VARCHAR(1000),
  "PRODUCT_DESC" VARCHAR(1000),
  "PROMO_FLAG" VARCHAR(1000),
  "PROMO_DISCOUNT" VARCHAR(1000),
  "BASE_PRICE" VARCHAR(1000),
  "IS_LIMITED_EDITION" VARCHAR(1000),
  "STORE_DESC" VARCHAR(1000),
  "STORE_CITY" VARCHAR(1000),
  "STORE_COUNTRY" VARCHAR(1000),
  "STORE_ADDRESS" VARCHAR(1000),
  "STORE_TYPE" VARCHAR(1000),
  "WEBSITE" VARCHAR(1000),
  "PAYMENT_METHOD" VARCHAR(1000),
  "PAYMENT_PROVIDER" VARCHAR(1000),
  "TRANSACTION_FEE_RATE" VARCHAR(1000),
  "IS_CONTACTLESS" VARCHAR(1000),
  "DAY_OF_WEEK" VARCHAR(1000),
  "DAY_OF_MONTH" VARCHAR(1000),
  "WEEK_ID" VARCHAR(1000),
  "MONTH_ID" VARCHAR(1000),
  "MONTH_DESC" VARCHAR(1000),
  "QUARTER_ID" VARCHAR(1000),
  "QUARTER_DESC" VARCHAR(1000),
  "YEAR_ID" VARCHAR(1000),
  "IS_WEEKEND" VARCHAR(1000),
  "DELIVERY_FEE" VARCHAR(1000)
)
SERVER csv_srv
OPTIONS (
  filename 'online_coffee_shop_transactions_new.csv',
  format 'csv',
  header 'true'
);


--SOURCE TABLE ONLINE
CREATE TABLE IF NOT EXISTS sa_online_sales.src_online_coffee_shop_transactions (
  "SALES_ID" VARCHAR(1000),
  "EVENT_DT" VARCHAR(1000),
  "CUSTOMER_ID" VARCHAR(1000),
  "PRODUCT_ID" VARCHAR(1000),
  "STORE_ID" VARCHAR(1000),
  "PAYMENT_ID" VARCHAR(1000),
  "QUANTITY" VARCHAR(1000),
  "LINE_ITEM_AMOUNT" VARCHAR(1000),
  "COST" VARCHAR(1000),
  "PROFIT" VARCHAR(1000),
  "PROFIT_MARGIN" VARCHAR(1000),
  "CUSTOMER_FIRST_NAME" VARCHAR(1000),
  "CUSTOMER_LAST_NAME" VARCHAR(1000),
  "CUSTOMER_COUNTRY" VARCHAR(1000),
  "LOYALTY_MEMBER" VARCHAR(1000),
  "LOYALTY_DISCOUNT" VARCHAR(1000),
  "SIGNUP_DT" VARCHAR(1000),
  "GENDER" VARCHAR(1000),
  "BIRTH_YEAR" VARCHAR(1000),
  "PRODUCT_GROUP" VARCHAR(1000),
  "PRODUCT_CATEGORY" VARCHAR(1000),
  "PRODUCT_TYPE" VARCHAR(1000),
  "PRODUCT_DESC" VARCHAR(1000),
  "PROMO_FLAG" VARCHAR(1000),
  "PROMO_DISCOUNT" VARCHAR(1000),
  "BASE_PRICE" VARCHAR(1000),
  "IS_LIMITED_EDITION" VARCHAR(1000),
  "STORE_DESC" VARCHAR(1000),
  "STORE_CITY" VARCHAR(1000),
  "STORE_COUNTRY" VARCHAR(1000),
  "STORE_ADDRESS" VARCHAR(1000),
  "STORE_TYPE" VARCHAR(1000),
  "WEBSITE" VARCHAR(1000),
  "PAYMENT_METHOD" VARCHAR(1000),
  "PAYMENT_PROVIDER" VARCHAR(1000),
  "TRANSACTION_FEE_RATE" VARCHAR(1000),
  "IS_CONTACTLESS" VARCHAR(1000),
  "DAY_OF_WEEK" VARCHAR(1000),
  "DAY_OF_MONTH" VARCHAR(1000),
  "WEEK_ID" VARCHAR(1000),
  "MONTH_ID" VARCHAR(1000),
  "MONTH_DESC" VARCHAR(1000),
  "QUARTER_ID" VARCHAR(1000),
  "QUARTER_DESC" VARCHAR(1000),
  "YEAR_ID" VARCHAR(1000),
  "IS_WEEKEND" VARCHAR(1000),
  "DELIVERY_FEE" VARCHAR(1000));

--POPULATING SOURCE ONLINE
--TRUNCATE sa_online_sales.src_online_coffee_shop_transactions;

INSERT INTO sa_online_sales.src_online_coffee_shop_transactions
SELECT  
  "SALES_ID",
  "EVENT_DT",
  "CUSTOMER_ID",
  "PRODUCT_ID",
  "STORE_ID",
  "PAYMENT_ID",
  "QUANTITY",
  "LINE_ITEM_AMOUNT",
  "COST",
  "PROFIT",
  "PROFIT_MARGIN",
  "CUSTOMER_FIRST_NAME",
  "CUSTOMER_LAST_NAME",
  "CUSTOMER_COUNTRY",
  "LOYALTY_MEMBER",
  "LOYALTY_DISCOUNT",
  "SIGNUP_DT",
  "GENDER",
  "BIRTH_YEAR",
  "PRODUCT_GROUP",
  "PRODUCT_CATEGORY",
  "PRODUCT_TYPE",
  "PRODUCT_DESC",
  "PROMO_FLAG",
  "PROMO_DISCOUNT",
  "BASE_PRICE",
  "IS_LIMITED_EDITION",
  "STORE_DESC",
  "STORE_CITY",
  "STORE_COUNTRY",
  "STORE_ADDRESS",
  "STORE_TYPE",
  "WEBSITE",
  "PAYMENT_METHOD",
  "PAYMENT_PROVIDER",
  "TRANSACTION_FEE_RATE",
  "IS_CONTACTLESS",
  "DAY_OF_WEEK",
  "DAY_OF_MONTH",
  "WEEK_ID",
  "MONTH_ID",
  "MONTH_DESC",
  "QUARTER_ID",
  "QUARTER_DESC",
  "YEAR_ID",
  "IS_WEEKEND",
  "DELIVERY_FEE"
FROM sa_online_sales.ext_online_coffee_shop_transactions ext
WHERE ((ext."EVENT_DT">(SELECT COALESCE(MAX("EVENT_DT"),'0') FROM sa_online_sales.src_online_coffee_shop_transactions)) OR
((ext."EVENT_DT"::bigint=(SELECT COALESCE(MAX("EVENT_DT"::bigint),0) FROM sa_online_sales.src_online_coffee_shop_transactions) 
  AND ext."SALES_ID">(SELECT COALESCE(MAX("SALES_ID"),'INV-ONL-000000') FROM sa_online_sales.src_online_coffee_shop_transactions))))
AND 
NOT EXISTS (SELECT 1 FROM sa_online_sales.src_online_coffee_shop_transactions WHERE "SALES_ID"=ext."SALES_ID");



--SOURCE TABLE OFFLINE
CREATE  TABLE IF NOT EXISTS sa_offline_sales.src_offline_coffee_shop_transactions(
   "SALES_ID" VARCHAR(1000),
  "EVENT_DT" VARCHAR(1000),
  "CUSTOMER_ID" VARCHAR(1000),
  "PRODUCT_ID" VARCHAR(1000),
  "STORE_ID" VARCHAR(1000),
  "STAFF_ID" VARCHAR(1000),
  "PAYMENT_ID" VARCHAR(1000),
  "QUANTITY" VARCHAR(1000),
  "LINE_ITEM_AMOUNT" VARCHAR(1000),
  "COST" VARCHAR(1000),
  "PROFIT" VARCHAR(1000),
  "PROFIT_MARGIN" VARCHAR(1000),
  "CUSTOMER_FIRST_NAME" VARCHAR(1000),
  "CUSTOMER_LAST_NAME" VARCHAR(1000),
  "CUSTOMER_COUNTRY" VARCHAR(1000),
  "LOYALTY_MEMBER" VARCHAR(1000),
  "LOYALTY_DISCOUNT" VARCHAR(1000),
  "PRODUCT_GROUP" VARCHAR(1000),
  "PRODUCT_CATEGORY" VARCHAR(1000),
  "PRODUCT_TYPE" VARCHAR(1000),
  "PRODUCT_DESC" VARCHAR(1000),
  "PROMO_FLAG" VARCHAR(1000),
  "PROMO_DISCOUNT" VARCHAR(1000),
  "BASE_PRICE" VARCHAR(1000),
  "IS_LIMITED_EDITION" VARCHAR(1000),
  "STORE_DESC" VARCHAR(1000),
  "STORE_CITY" VARCHAR(1000),
  "STORE_COUNTRY" VARCHAR(1000),
  "STORE_ADDRESS" VARCHAR(1000),
  "STORE_FLOOR_AREA" VARCHAR(1000),
  "STORE_TYPE" VARCHAR(1000),
  "MANAGER_ID" VARCHAR(1000),
  "STAFF_FIRST_NAME" VARCHAR(1000),
  "STAFF_LAST_NAME" VARCHAR(1000),
  "STAFF_JOB_DESC" VARCHAR(1000),
  "JOB_START_DT" VARCHAR(1000),
  "EMPLOYMENT_STATUS" VARCHAR(1000),
  "HOURLY_WAGE" VARCHAR(1000),
  "PAYMENT_METHOD" VARCHAR(1000),
  "PAYMENT_PROVIDER" VARCHAR(1000),
  "TRANSACTION_FEE" VARCHAR(1000),
  "IS_CONTACTLESS" VARCHAR(1000),
  "DAY_OF_WEEK" VARCHAR(1000),
  "DAY_OF_MONTH" VARCHAR(1000),
  "WEEK_ID" VARCHAR(1000),
  "MONTH_ID" VARCHAR(1000),
  "MONTH_DESC" VARCHAR(1000),
  "QUARTER_ID" VARCHAR(1000),
  "QUARTER_DESC" VARCHAR(1000),
  "YEAR_ID" VARCHAR(1000),
  "IS_WEEKEND" VARCHAR(1000));


--POPULATING SOURCE OFFLINE
--TRUNCATE sa_offline_sales.src_offline_coffee_shop_transactions;
INSERT INTO sa_offline_sales.src_offline_coffee_shop_transactions
SELECT   
  "SALES_ID",
  "EVENT_DT",
  "CUSTOMER_ID",
  "PRODUCT_ID",
  "STORE_ID",
  "STAFF_ID",
  "PAYMENT_ID",
  "QUANTITY",
  "LINE_ITEM_AMOUNT",
  "COST",
  "PROFIT",
  "PROFIT_MARGIN",
  "CUSTOMER_FIRST_NAME",
  "CUSTOMER_LAST_NAME",
  "CUSTOMER_COUNTRY",
  "LOYALTY_MEMBER",
  "LOYALTY_DISCOUNT",
  "PRODUCT_GROUP",
  "PRODUCT_CATEGORY",
  "PRODUCT_TYPE",
  "PRODUCT_DESC",
  "PROMO_FLAG",
  "PROMO_DISCOUNT",
  "BASE_PRICE",
  "IS_LIMITED_EDITION",
  "STORE_DESC",
  "STORE_CITY",
  "STORE_COUNTRY",
  "STORE_ADDRESS",
  "STORE_FLOOR_AREA",
  "STORE_TYPE",
  "MANAGER_ID",
  "STAFF_FIRST_NAME",
  "STAFF_LAST_NAME",
  "STAFF_JOB_DESC",
  "JOB_START_DT",
  "EMPLOYMENT_STATUS",
  "HOURLY_WAGE",
  "PAYMENT_METHOD",
  "PAYMENT_PROVIDER",
  "TRANSACTION_FEE",
  "IS_CONTACTLESS",
  "DAY_OF_WEEK",
  "DAY_OF_MONTH",
  "WEEK_ID",
  "MONTH_ID",
  "MONTH_DESC",
  "QUARTER_ID",
  "QUARTER_DESC",
  "YEAR_ID",
  "IS_WEEKEND" 
 FROM sa_offline_sales.ext_offline_coffee_shop_transactions ext
 WHERE ((ext."EVENT_DT">(SELECT COALESCE(MAX("EVENT_DT"),'0') FROM sa_offline_sales.src_offline_coffee_shop_transactions)) OR
((ext."EVENT_DT"::bigint=(SELECT COALESCE(MAX("EVENT_DT"::bigint),0) FROM sa_offline_sales.src_offline_coffee_shop_transactions) 
  AND ext."SALES_ID">(SELECT COALESCE(MAX("SALES_ID"),'INV-OFL-000000') FROM sa_offline_sales.src_offline_coffee_shop_transactions)))) AND
NOT EXISTS (SELECT 1 FROM sa_offline_sales.src_offline_coffee_shop_transactions WHERE "SALES_ID"=ext."SALES_ID") ;
COMMIT;


--SELECT * FROM sa_online_sales.ext_online_coffee_shop_transactions;
--SELECT * FROM sa_online_sales.src_online_coffee_shop_transactions ;
--
--SELECT * FROM sa_offline_sales.ext_offline_coffee_shop_transactions;
--SELECT * FROM sa_offline_sales.src_offline_coffee_shop_transactions ;

--DUPLICATE CHECKS
SELECT count("SALES_ID") AS sale_id_count FROM sa_online_sales.src_online_coffee_shop_transactions;
SELECT count("SALES_ID") AS sale_id_count  FROM sa_offline_sales.src_offline_coffee_shop_transactions;

--BL_CL SCHEMA CREATION
CREATE SCHEMA IF NOT EXISTS BL_CL;

--MAPPING TABLE FOR CUSTOMERS
--TRUNCATE BL_CL.t_map_customers;
CREATE TABLE IF NOT EXISTS BL_CL.t_map_customers (
    "CUSTOMER_ID" BIGINT NOT NULL,
    "CUSTOMER_SRC_FIRST_NAME" VARCHAR(1000) not NULL,
    "CUSTOMER_SRC_LAST_NAME" VARCHAR(1000) not null ,
    "CUSTOMER_SRC_ID" VARCHAR(1000) NOT NULL,
    "CUSTOMER_FIRST_NAME" VARCHAR(1000) NOT NULL,
    "CUSTOMER_LAST_NAME" VARCHAR(1000) NOT NULL,
    "SOURCE_SYSTEM" VARCHAR(255) NOT NULL,
    "SOURCE_ENTITY" VARCHAR(255) NOT NULL);
WITH all_sources AS (
  SELECT DISTINCT 
    "CUSTOMER_ID" AS "CUSTOMER_SRC_ID",
    "CUSTOMER_FIRST_NAME" AS "CUSTOMER_SRC_FIRST_NAME",
    "CUSTOMER_LAST_NAME" AS "CUSTOMER_SRC_LAST_NAME",
    TRIM(LOWER("CUSTOMER_FIRST_NAME")) AS "norm_first_name",
    TRIM(LOWER("CUSTOMER_LAST_NAME")) AS "norm_last_name",
     "EVENT_DT",
    'SA_ONLINE_SALES' AS "SOURCE_SYSTEM",
    'SRC_ONLINE_COFFEE_SHOP_TRANSACTIONS' AS "SOURCE_ENTITY"
  FROM sa_online_sales.src_online_coffee_shop_transactions
  UNION ALL
  SELECT DISTINCT 
    "CUSTOMER_ID",
    "CUSTOMER_FIRST_NAME",
    "CUSTOMER_LAST_NAME",
    TRIM(LOWER("CUSTOMER_FIRST_NAME")),
    TRIM(LOWER("CUSTOMER_LAST_NAME")),
    "EVENT_DT",
    'SA_OFFLINE_SALES',
    'SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS'
  FROM sa_offline_sales.src_offline_coffee_shop_transactions
),
latest_cust AS (SELECT *,row_number() OVER (PARTITION BY "CUSTOMER_SRC_ID","SOURCE_ENTITY","SOURCE_SYSTEM" ORDER BY "EVENT_DT" DESC) AS rn FROM ALL_SOURCES),
assigned_ids AS (
  SELECT  ROW_NUMBER() OVER (ORDER BY "CUSTOMER_SRC_ID" ) AS "CUSTOMER_ID",
    "CUSTOMER_SRC_ID"
  FROM (
    SELECT DISTINCT "CUSTOMER_SRC_ID"
    FROM latest_cust
    WHERE rn =1
  ) AS unique_customers
)
INSERT INTO BL_CL.t_map_customers (
  "CUSTOMER_ID",
  "CUSTOMER_SRC_FIRST_NAME",
  "CUSTOMER_SRC_LAST_NAME",
  "CUSTOMER_SRC_ID",
  "CUSTOMER_FIRST_NAME",
  "CUSTOMER_LAST_NAME",
  "SOURCE_SYSTEM",
  "SOURCE_ENTITY"
)
SELECT 
  aid."CUSTOMER_ID",
  src."CUSTOMER_SRC_FIRST_NAME",
  src."CUSTOMER_SRC_LAST_NAME",
  src."CUSTOMER_SRC_ID",
  INITCAP(src."norm_first_name") AS "CUSTOMER_FIRST_NAME",
  INITCAP(src."norm_last_name") AS "CUSTOMER_LAST_NAME",
  src."SOURCE_SYSTEM",
  src."SOURCE_ENTITY"
FROM latest_cust src
JOIN assigned_ids aid
  ON src."CUSTOMER_SRC_ID" = aid."CUSTOMER_SRC_ID"
  WHERE src.rn=1 AND NOT EXISTS (SELECT 1 FROM BL_CL.t_map_customers WHERE "CUSTOMER_SRC_ID"=src."CUSTOMER_SRC_ID");
--SELECT * FROM BL_CL.t_map_customers;



--MAPPING TABLE FOR PRODUCTS
 --TRUNCATE BL_CL.t_map_products;

 CREATE TABLE IF NOT EXISTS BL_CL.t_map_products (
    "PRODUCT_ID" BIGINT NOT NULL,
    "PRODUCT_SRC_ID" VARCHAR(1000) NOT NULL,
    "PRODUCT_SRC_DESC" VARCHAR(1000) NOT NULL,
    "PRODUCT_DESC"  VARCHAR(1000) NOT NULL,
    "SOURCE_SYSTEM" VARCHAR(1000) NOT NULL,
    "SOURCE_ENTITY" VARCHAR(1000) NOT NULL);
 
WITH all_products AS (
  SELECT DISTINCT
    "PRODUCT_ID" AS "PRODUCT_SRC_ID",
    "PRODUCT_DESC" AS "PRODUCT_SRC_DESC",
    TRIM(UPPER("PRODUCT_DESC")) AS "norm_desc",
    "EVENT_DT"::bigint,
    'SA_ONLINE_SALES' AS "SOURCE_SYSTEM",
    'SRC_ONLINE_COFFEE_SHOP_TRANSACTIONS' AS "SOURCE_ENTITY"
  FROM sa_online_sales.src_online_coffee_shop_transactions

  UNION ALL

  SELECT DISTINCT
    "PRODUCT_ID" AS "PRODUCT_SRC_ID",
    "PRODUCT_DESC" AS "PRODUCT_SRC_DESC",
    TRIM(UPPER("PRODUCT_DESC")) AS "norm_desc",
    "EVENT_DT"::bigint,
    'SA_OFFLINE_SALES' AS "SOURCE_SYSTEM",
    'SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS' AS "SOURCE_ENTITY"
  FROM sa_offline_sales.src_offline_coffee_shop_transactions
),
latest_products AS (SELECT *,ROW_NUMBER() over(PARTITION BY "PRODUCT_SRC_ID","SOURCE_SYSTEM","SOURCE_ENTITY" ORDER BY "EVENT_DT" DESC ) AS rn FROM all_products),
assigned_ids AS ( SELECT  ROW_NUMBER() OVER (ORDER BY "PRODUCT_SRC_ID") AS "PRODUCT_ID",  "PRODUCT_SRC_ID"
  FROM (  SELECT DISTINCT "PRODUCT_SRC_ID" FROM latest_products ) AS unique_products)

INSERT INTO BL_CL.t_map_products (
  "PRODUCT_ID",
  "PRODUCT_SRC_ID",
  "PRODUCT_SRC_DESC",
  "PRODUCT_DESC",
  "SOURCE_SYSTEM",
  "SOURCE_ENTITY"
)
SELECT
  aid."PRODUCT_ID",
  src."PRODUCT_SRC_ID",
  src."PRODUCT_SRC_DESC",
  upper(src."norm_desc") AS "PRODUCT_DESC",
  src."SOURCE_SYSTEM",
  src."SOURCE_ENTITY"
FROM latest_products src
JOIN assigned_ids aid
  ON src."PRODUCT_SRC_ID" = aid."PRODUCT_SRC_ID"
WHERE rn=1 AND NOT EXISTS(SELECT 1 FROM  BL_CL.t_map_products WHERE "PRODUCT_SRC_ID"=src."PRODUCT_SRC_ID" );

--SELECT * FROM BL_CL.T_MAP_PRODUCTS;


--FOR 3NF TABLES FOR PROCEDURES LOGGING 
CREATE SEQUENCE IF NOT EXISTS BL_CL.ETL_LOG_SEQ START 1;
CREATE TABLE IF NOT EXISTS BL_CL.ETL_LOG (
    ID BIGINT PRIMARY KEY,
    LOG_TIME TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PROCEDURE_NAME TEXT,
    ROWS_AFFECTED INT,
    MESSAGE TEXT);
COMMIT;

--FOR DM LAYER
CREATE SEQUENCE IF NOT EXISTS BL_CL.ETL_LOG_DM_SEQ START 1;
CREATE TABLE IF NOT EXISTS BL_CL.ETL_LOG_DM (
    ID BIGINT PRIMARY KEY,
    LOG_TIME TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PROCEDURE_NAME TEXT,
    ROWS_AFFECTED INT,
    MESSAGE TEXT);

--FOR INCREMENTAL_LOAD
CREATE TABLE IF NOT EXISTS bl_cl.load_tracker(
source_type varchar(20) PRIMARY KEY,
last_event_dt bigint NOT NULL,
last_transaction_id varchar(100) NOT NULL,
last_updated timestamp NOT NULL
);
INSERT INTO bl_cl.load_tracker
VALUES ('ONLINE',-1,'n.a.',current_timestamp),
	   ('OFFLINE',-1,'n.a.',current_timestamp)
ON CONFLICT(source_type) DO nothing;

--------------------------------------------------------------------
--3NF TABLES CREATION
CREATE SCHEMA IF NOT EXISTS BL_3NF;

--CE_PRODUCT_GROUPS
 CREATE SEQUENCE IF NOT EXISTS BL_3NF.CE_PRODUCT_GROUPS_SEQ START 1;
    CREATE TABLE IF NOT EXISTS BL_3NF.CE_PRODUCT_GROUPS(
    "PRODUCT_GROUP_ID" BIGINT PRIMARY KEY,
    "PRODUCT_GROUP_SRC_ID" VARCHAR(255) NOT NULL,
    "PRODUCT_GROUP_DESC" VARCHAR(255) NOT NULL,
    "TA_INSERT_DT" TIMESTAMP NOT NULL,
    "SOURCE_SYSTEM" VARCHAR(255) NOT NULL,
    "SOURCE_ENTITY" VARCHAR(255) NOT NULL
    );  
    COMMIT;
    ALTER TABLE IF EXISTS BL_3NF.CE_PRODUCT_GROUPS
    DROP CONSTRAINT IF EXISTS unique_product_groups_source_triplet;
    ALTER TABLE IF EXISTS BL_3NF.CE_PRODUCT_GROUPS
    ADD CONSTRAINT unique_product_groups_source_triplet
    UNIQUE("PRODUCT_GROUP_SRC_ID","SOURCE_SYSTEM","SOURCE_ENTITY");
    COMMIT;
    --DEFAULT ROW
    INSERT INTO BL_3NF.CE_PRODUCT_GROUPS
    SELECT -1,'n.a.','n.a','1900-01-01'::timestamp,'MANUAL','MANUAL'
    WHERE NOT EXISTS(SELECT 1 FROM BL_3NF.CE_PRODUCT_GROUPS WHERE "PRODUCT_GROUP_ID" =-1)  ;
    COMMIT;


--CE_PRODUCT_CATEGORIES
    CREATE SEQUENCE IF NOT EXISTS BL_3NF.CE_PRODUCT_CATEGORIES_SEQ START 1;
    CREATE TABLE IF NOT EXISTS BL_3NF.CE_PRODUCT_CATEGORIES(
    "PRODUCT_CATEGORY_ID" BIGINT PRIMARY KEY,
    "PRODUCT_CATEGORY_SRC_ID" VARCHAR(255) NOT NULL,
    "PRODUCT_GROUP_ID" BIGINT NOT NULL,
    "PRODUCT_CATEGORY_DESC" VARCHAR(255) NOT NULL,
    "TA_INSERT_DT" TIMESTAMP NOT NULL,
    "SOURCE_SYSTEM" VARCHAR(255) NOT NULL,
    "SOURCE_ENTITY" VARCHAR(255) NOT NULL,
    FOREIGN KEY("PRODUCT_GROUP_ID") REFERENCES BL_3NF.CE_PRODUCT_GROUPS("PRODUCT_GROUP_ID")
    );
    COMMIT;
    ALTER TABLE IF EXISTS BL_3NF.CE_PRODUCT_CATEGORIES
    DROP CONSTRAINT IF EXISTS unique_product_categories_source_triplet;
    ALTER TABLE IF EXISTS BL_3NF.CE_PRODUCT_CATEGORIES
    ADD CONSTRAINT unique_product_categories_source_triplet
    UNIQUE("PRODUCT_CATEGORY_SRC_ID","SOURCE_SYSTEM","SOURCE_ENTITY");
    COMMIT;
    --DEFAULT ROW
	INSERT INTO BL_3NF.CE_PRODUCT_CATEGORIES
    SELECT -1,'n.a',-1,'n.a','1900-01-01'::timestamp,'MANUAL','MANUAL'
    WHERE NOT EXISTS(SELECT 1 FROM BL_3NF.CE_PRODUCT_CATEGORIES WHERE "PRODUCT_CATEGORY_ID"=-1) ;
	COMMIT;



--CE_PRODUCT_TYPES
    CREATE SEQUENCE IF NOT EXISTS BL_3NF.CE_PRODUCT_TYPES_SEQ START 1;
    CREATE TABLE IF NOT EXISTS BL_3NF.CE_PRODUCT_TYPES(
    "PRODUCT_TYPE_ID" BIGINT PRIMARY KEY,
    "PRODUCT_TYPE_SRC_ID" VARCHAR(255) NOT NULL,
    "PRODUCT_CATEGORY_ID" BIGINT NOT NULL,
    "PRODUCT_TYPE_DESC" VARCHAR(255) NOT NULL,
    "TA_INSERT_DT" TIMESTAMP NOT NULL,
    "SOURCE_SYSTEM" VARCHAR(255) NOT NULL,
    "SOURCE_ENTITY" VARCHAR(255) NOT NULL,
    FOREIGN KEY("PRODUCT_CATEGORY_ID") REFERENCES BL_3NF.CE_PRODUCT_CATEGORIES("PRODUCT_CATEGORY_ID")
    );
    COMMIT;
    ALTER TABLE IF EXISTS BL_3NF.CE_PRODUCT_TYPES
    DROP CONSTRAINT IF EXISTS unique_product_types_source_triplet;
    ALTER TABLE IF EXISTS BL_3NF.CE_PRODUCT_TYPES
    ADD CONSTRAINT unique_product_types_source_triplet
    UNIQUE("PRODUCT_TYPE_SRC_ID","SOURCE_SYSTEM","SOURCE_ENTITY");
    COMMIT;
    --DEFAULT ROW
    INSERT INTO BL_3NF.CE_PRODUCT_TYPES
    SELECT -1,'n.a',-1,'n.a','1900-01-01'::timestamp,'MANUAL','MANUAL'
    WHERE NOT EXISTS (SELECT 1 FROM BL_3NF.CE_PRODUCT_TYPES WHERE  "PRODUCT_TYPE_ID" =-1 );
	COMMIT;



--CE_PRODUCTS
CREATE SEQUENCE IF NOT EXISTS BL_3NF.CE_PRODUCTS_SEQ START 1;
   CREATE TABLE IF NOT EXISTS BL_3NF.CE_PRODUCTS(
    "PRODUCT_ID" BIGINT PRIMARY KEY,
    "PRODUCT_SRC_ID" bigint NOT NULL,
    "PRODUCT_TYPE_ID" BIGINT NOT NULL,
    "PRODUCT_DESC" VARCHAR(255) NOT NULL,
    "PROMO_FLAG" BOOLEAN NOT NULL,
    "PROMO_DISCOUNT" DECIMAL(6,2) NOT NULL,
    "BASE_PRICE" DECIMAL(12,2) NOT NULL,
    "IS_LIMITED_EDITION" BOOLEAN NOT NULL,
    "TA_INSERT_DT" TIMESTAMP NOT NULL,
    "SOURCE_SYSTEM" VARCHAR(255) NOT NULL,
    "SOURCE_ENTITY" VARCHAR(255) NOT NULL,
    FOREIGN KEY("PRODUCT_TYPE_ID") REFERENCES BL_3NF.CE_PRODUCT_TYPES("PRODUCT_TYPE_ID")
    );
    COMMIT;
    ALTER TABLE IF EXISTS BL_3NF.CE_PRODUCTS
    DROP CONSTRAINT IF EXISTS unique_products_source_triplet;
    ALTER TABLE IF EXISTS BL_3NF.CE_PRODUCTS
    ADD CONSTRAINT unique_products_source_triplet
    UNIQUE("PRODUCT_SRC_ID","SOURCE_SYSTEM","SOURCE_ENTITY");
    COMMIT;
    --DEFAULT ROW
    INSERT INTO BL_3NF.CE_PRODUCTS
    SELECT -1,-1,-1,'n.a',FALSE,-1,-1,FALSE,'1900-01-01'::timestamp,'MANUAL','MANUAL'
    WHERE NOT EXISTS(SELECT 1 FROM BL_3NF.CE_PRODUCTS WHERE "PRODUCT_ID"=-1 );
	COMMIT;
    


--CE_COUNTRIES
CREATE SEQUENCE IF NOT EXISTS BL_3NF.CE_COUNTRIES_SEQ START 1;
CREATE TABLE IF NOT EXISTS BL_3NF.CE_COUNTRIES(
    "COUNTRY_ID" BIGINT PRIMARY KEY,
    "COUNTRY_SRC_ID" VARCHAR(255) NOT NULL,
    "COUNTRY_DESC" VARCHAR(255) NOT NULL,
    "TA_INSERT_DT" TIMESTAMP NOT NULL,
    "SOURCE_SYSTEM" VARCHAR(255) NOT NULL,
    "SOURCE_ENTITY" VARCHAR(255) NOT NULL);
	COMMIT;
	ALTER TABLE IF EXISTS BL_3NF.CE_COUNTRIES
    DROP CONSTRAINT IF EXISTS unique_countries_source_triplet;
 	ALTER TABLE IF EXISTS BL_3NF.CE_COUNTRIES
    ADD CONSTRAINT unique_countries_source_triplet
    UNIQUE("COUNTRY_SRC_ID","SOURCE_SYSTEM","SOURCE_ENTITY");
    COMMIT;
--DEFAULT ROW
   INSERT INTO BL_3NF.CE_COUNTRIES
   SELECT -1,'n.a','n.a','1900-01-01'::timestamp,'MANUAL','MANUAL'
   WHERE NOT EXISTS(SELECT 1 FROM BL_3NF.CE_COUNTRIES WHERE "COUNTRY_ID"=-1);
	COMMIT;



--CE_CITIES
CREATE SEQUENCE IF NOT EXISTS BL_3NF.CE_CITIES_SEQ START 1;
CREATE TABLE IF NOT EXISTS BL_3NF.CE_CITIES(
    "CITY_ID" BIGINT PRIMARY KEY,
    "CITY_SRC_ID" VARCHAR(100) NOT NULL,
    "COUNTRY_ID" BIGINT NOT NULL,
    "CITY_DESC" VARCHAR(100) NOT NULL,
    "TA_INSERT_DT" TIMESTAMP NOT NULL,
    "SOURCE_SYSTEM" VARCHAR(150) NOT NULL,
    "SOURCE_ENTITY" VARCHAR(150) NOT NULL,
    FOREIGN KEY("COUNTRY_ID") REFERENCES BL_3NF.CE_COUNTRIES("COUNTRY_ID"));
    COMMIT;
    ALTER TABLE IF EXISTS BL_3NF.CE_CITIES
    DROP CONSTRAINT IF EXISTS unique_cities_source_triplet;
    ALTER TABLE IF EXISTS BL_3NF.CE_CITIES
    ADD CONSTRAINT unique_cities_source_triplet
    UNIQUE("CITY_SRC_ID","SOURCE_SYSTEM","SOURCE_ENTITY");
    COMMIT;
    --DEFAULT ROW
   INSERT INTO BL_3NF.CE_CITIES
   SELECT -1,-1,-1,'n.a','1900-01-01'::timestamp,'MANUAL','MANUAL'
   WHERE NOT EXISTS (SELECT 1 FROM BL_3NF.CE_CITIES WHERE "CITY_ID" =-1);
   COMMIT;



--CE_STAFF
    CREATE SEQUENCE IF NOT EXISTS BL_3NF.CE_STAFF_SEQ START 1;
    CREATE TABLE IF NOT EXISTS BL_3NF.CE_STAFF(
    "STAFF_ID" BIGINT PRIMARY KEY,
    "STAFF_SRC_ID" VARCHAR(100) NOT NULL,
    "STAFF_FIRST_NAME" VARCHAR(50) NOT NULL,
    "STAFF_LAST_NAME" VARCHAR(50) NOT NULL,
    "JOB_START_DT" DATE NOT NULL,
    "EMPLOYMENT_STATUS" VARCHAR(30) NOT NULL,
    "HOURLY_WAGE" DECIMAL(10,2) NOT NULL,    
    "TA_INSERT_DT" TIMESTAMP NOT NULL,
    "SOURCE_SYSTEM" VARCHAR(150) NOT NULL,
    "SOURCE_ENTITY" VARCHAR(150) NOT NULL);
    COMMIT;
	ALTER TABLE IF EXISTS BL_3NF.CE_STAFF
    DROP CONSTRAINT IF EXISTS unique_staff_source_triplet;
 	ALTER TABLE IF EXISTS BL_3NF.CE_STAFF
    ADD CONSTRAINT unique_staff_source_triplet
    UNIQUE("STAFF_SRC_ID","SOURCE_SYSTEM","SOURCE_ENTITY");
    COMMIT;
  --DEFAULT ROW
   INSERT INTO BL_3NF.CE_STAFF
   SELECT -1,'n.a','n.a','n.a','1900-01-01'::date,'n.a.',-1,'1900-01-01'::timestamp,'MANUAL','MANUAL'
   WHERE NOT EXISTS (SELECT 1 FROM BL_3NF.CE_STAFF WHERE "STAFF_ID" =-1);
   COMMIT;

--CE_STORES

    CREATE SEQUENCE IF NOT EXISTS BL_3NF.CE_STORES_SEQ START 1;
    CREATE TABLE IF NOT EXISTS BL_3NF.CE_STORES(
    "STORE_ID" BIGINT PRIMARY KEY,
    "STORE_SRC_ID" VARCHAR(50) NOT NULL,
    "CITY_ID" BIGINT NOT NULL,
    "WEBSITE" VARCHAR(150) NOT NULL,
    "STORE_DESC" VARCHAR(100) NOT NULL,
    "STORE_ADDRESS" VARCHAR(200) NOT NULL,
    "STORE_TYPE" VARCHAR(100) NOT NULL,
    "TA_INSERT_DT" TIMESTAMP NOT NULL,
    "SOURCE_SYSTEM" VARCHAR(150) NOT NULL,
    "SOURCE_ENTITY" VARCHAR(150) NOT NULL,
    FOREIGN KEY("CITY_ID") REFERENCES BL_3NF.CE_CITIES("CITY_ID"));
    COMMIT;
    ALTER TABLE IF EXISTS BL_3NF.CE_STORES
    DROP CONSTRAINT IF EXISTS unique_stores_source_triplet;
    ALTER TABLE IF EXISTS BL_3NF.CE_STORES
    ADD CONSTRAINT unique_stores_source_triplet
    UNIQUE("STORE_SRC_ID","SOURCE_SYSTEM","SOURCE_ENTITY");
    COMMIT;
    --DEFAULT ROW
   INSERT INTO BL_3NF.CE_STORES
   SELECT -1,'n.a',-1,'n.a','n.a','n.a','n.a','1900-01-01'::timestamp,'MANUAL','MANUAL'
   WHERE NOT EXISTS (SELECT * FROM BL_3NF.CE_STORES WHERE "STORE_ID" =-1);
    COMMIT;
    
 --CE_JOBS
    CREATE SEQUENCE IF NOT EXISTS BL_3NF.CE_JOBS_SEQ START 1;
    CREATE TABLE IF NOT EXISTS BL_3NF.CE_JOBS(
    "JOB_ID" BIGINT PRIMARY KEY,
    "JOB_SRC_ID" VARCHAR(255) NOT NULL,
    "JOB_DESC" VARCHAR(255) NOT NULL,
    "TA_INSERT_DT" TIMESTAMP NOT NULL,
    "SOURCE_SYSTEM" VARCHAR(255) NOT NULL,
    "SOURCE_ENTITY" VARCHAR(255) NOT NULL);
    COMMIT;
    ALTER TABLE IF EXISTS BL_3NF.CE_JOBS
    DROP CONSTRAINT IF EXISTS unique_jobs_source_triplet;
    ALTER TABLE IF EXISTS BL_3NF.CE_JOBS
    ADD CONSTRAINT unique_jobs_source_triplet
    UNIQUE("JOB_SRC_ID","SOURCE_SYSTEM","SOURCE_ENTITY");
    COMMIT;
      --DEFAULT ROW
   INSERT INTO BL_3NF.CE_JOBS
   SELECT -1,'n.a','n.a','1900-01-01'::timestamp,'MANUAL','MANUAL'
   WHERE NOT EXISTS (SELECT 1 FROM BL_3NF.CE_JOBS WHERE "JOB_ID" =-1);
	COMMIT;
    
 
 --CE_STAFF_JOBS
  CREATE SEQUENCE IF NOT EXISTS BL_3NF.CE_STAFF_JOBS_SEQ START 1;
    CREATE TABLE IF NOT EXISTS BL_3NF.CE_STAFF_JOBS(
    "STAFF_JOB_ID" BIGINT PRIMARY KEY,
    "STAFF_JOB_SRC_ID" VARCHAR(100) NOT NULL,
    "STAFF_ID" BIGINT NOT NULL,
    "JOB_ID" BIGINT NOT NULL,
    "TA_INSERT_DT" TIMESTAMP NOT NULL,
    "SOURCE_SYSTEM" VARCHAR(150) NOT NULL,
    "SOURCE_ENTITY" VARCHAR(150) NOT NULL,
    FOREIGN KEY("STAFF_ID") REFERENCES BL_3NF.CE_STAFF("STAFF_ID"),
    FOREIGN KEY("JOB_ID") REFERENCES BL_3NF.CE_JOBS("JOB_ID"));
    COMMIT;
    ALTER TABLE IF EXISTS BL_3NF.CE_STAFF_JOBS
    DROP CONSTRAINT IF EXISTS unique_staff_jobs_source_triplet;
    ALTER TABLE IF EXISTS BL_3NF.CE_STAFF_JOBS
    ADD CONSTRAINT unique_staff_jobs_source_triplet
    UNIQUE("STAFF_JOB_SRC_ID","SOURCE_SYSTEM","SOURCE_ENTITY");
    COMMIT;
	  --DEFAULT ROW
   INSERT INTO BL_3NF.CE_STAFF_JOBS
   SELECT -1,'n.a',-1,-1,'1900-01-01'::timestamp,'MANUAL','MANUAL'
   WHERE NOT EXISTS (SELECT 1 FROM BL_3NF.CE_STAFF_JOBS WHERE "STAFF_JOB_ID" =-1);
	COMMIT;
    
--CE_STAFF_STORES
  CREATE SEQUENCE IF NOT EXISTS BL_3NF.CE_STAFF_STORES_SEQ START 1;
    CREATE TABLE IF NOT EXISTS BL_3NF.CE_STAFF_STORES(
    "STAFF_STORE_ID" BIGINT PRIMARY KEY,
    "STAFF_STORE_SRC_ID" VARCHAR(150) NOT NULL,
    "STAFF_ID" BIGINT NOT NULL,
    "STORE_ID" BIGINT NOT NULL,
    "TA_INSERT_DT" TIMESTAMP NOT NULL,
    "SOURCE_SYSTEM" VARCHAR(150) NOT NULL,
    "SOURCE_ENTITY" VARCHAR(150) NOT NULL,
    FOREIGN KEY("STAFF_ID") REFERENCES BL_3NF.CE_STAFF("STAFF_ID"),
    FOREIGN KEY("STORE_ID") REFERENCES BL_3NF.CE_STORES("STORE_ID"));
    COMMIT;
    ALTER TABLE IF EXISTS BL_3NF.CE_STAFF_STORES
    DROP CONSTRAINT IF EXISTS unique_staff_stores_source_triplet;
    ALTER TABLE IF EXISTS BL_3NF.CE_STAFF_STORES
    ADD CONSTRAINT unique_staff_stores_source_triplet
    UNIQUE("STAFF_STORE_SRC_ID","SOURCE_SYSTEM","SOURCE_ENTITY");
    COMMIT;
    --DEFAULT ROW
    INSERT INTO BL_3NF.CE_STAFF_STORES
    SELECT -1,'n.a',-1,-1,'1900-01-01'::timestamp,'MANUAL','MANUAL'
    WHERE NOT EXISTS (SELECT 1 FROM BL_3NF.CE_STAFF_STORES WHERE "STAFF_STORE_ID" =-1);
    COMMIT;


--CE_PAYMENT_METHODS
CREATE SEQUENCE IF NOT EXISTS BL_3NF.CE_PAYMENT_METHODS_SEQ START 1;
    CREATE TABLE IF NOT EXISTS BL_3NF.CE_PAYMENT_METHODS(
    "PAYMENT_METHOD_ID" BIGINT PRIMARY KEY,
    "PAYMENT_METHOD_SRC_ID" VARCHAR(255) NOT NULL,
    "PAYMENT_METHOD_DESC" VARCHAR(255) NOT NULL,
    "IS_CONTACTLESS" BOOLEAN NOT NULL,
    "TA_INSERT_DT" TIMESTAMP NOT NULL,
    "SOURCE_SYSTEM" VARCHAR(255) NOT NULL,
    "SOURCE_ENTITY" VARCHAR(255) NOT NULL);
    COMMIT;
    ALTER TABLE IF EXISTS BL_3NF.CE_PAYMENT_METHODS
    DROP CONSTRAINT IF EXISTS unique_payment_methods_source_triplet;
    ALTER TABLE IF EXISTS BL_3NF.CE_PAYMENT_METHODS
    ADD CONSTRAINT unique_payment_methods_source_triplet
    UNIQUE("PAYMENT_METHOD_SRC_ID","SOURCE_SYSTEM","SOURCE_ENTITY");
    COMMIT;
    --DEFAULT ROW
   INSERT INTO BL_3NF.CE_PAYMENT_METHODS
   SELECT -1,'n.a.','n.a.',TRUE,'1900-01-01'::timestamp,'MANUAL','MANUAL'
   WHERE NOT EXISTS (SELECT 1 FROM BL_3NF.CE_PAYMENT_METHODS WHERE "PAYMENT_METHOD_ID" =-1);
	COMMIT;

--CE_PAYMENT_PROVIDERS
CREATE SEQUENCE IF NOT EXISTS BL_3NF.CE_PAYMENT_PROVIDERS_SEQ START 1;
    CREATE TABLE IF NOT EXISTS BL_3NF.CE_PAYMENT_PROVIDERS(
    "PAYMENT_PROVIDER_ID" BIGINT PRIMARY KEY,
    "PAYMENT_PROVIDER_SRC_ID" VARCHAR(100) NOT NULL,
    "PAYMENT_PROVIDER_DESC" VARCHAR(100) NOT NULL,
    "TA_INSERT_DT" TIMESTAMP NOT NULL,
    "SOURCE_SYSTEM" VARCHAR(150) NOT NULL,
    "SOURCE_ENTITY" VARCHAR(150) NOT NULL);
    COMMIT;
    ALTER TABLE IF EXISTS BL_3NF.CE_PAYMENT_PROVIDERS
    DROP CONSTRAINT IF EXISTS unique_payment_provider_source_triplet;
    ALTER TABLE IF EXISTS BL_3NF.CE_PAYMENT_PROVIDERS
    ADD CONSTRAINT unique_payment_provider_source_triplet
    UNIQUE("PAYMENT_PROVIDER_SRC_ID","SOURCE_SYSTEM","SOURCE_ENTITY");
    COMMIT;
        --DEFAULT ROW
INSERT INTO BL_3NF.CE_PAYMENT_PROVIDERS
SELECT -1,'n.a.','n.a','1900-01-01'::timestamp,'MANUAL','MANUAL'
WHERE NOT EXISTS (SELECT 1 FROM BL_3NF.CE_PAYMENT_PROVIDERS WHERE "PAYMENT_PROVIDER_ID" =-1);
COMMIT;


--CE_PAYMENTS
CREATE SEQUENCE IF NOT EXISTS BL_3NF.CE_PAYMENTS_SEQ START 1;
    CREATE TABLE IF NOT EXISTS BL_3NF.CE_PAYMENTS(
    "PAYMENT_ID" BIGINT PRIMARY KEY,
    "PAYMENT_SRC_ID" BIGINT NOT NULL,
    "PAYMENT_PROVIDER_ID" BIGINT NOT NULL,
    "PAYMENT_METHOD_ID" BIGINT NOT NULL,
    "TRANSACTION_FEE" DECIMAL(8,2) NOT NULL,
    "TA_INSERT_DT" TIMESTAMP NOT NULL,
    "SOURCE_SYSTEM" VARCHAR(255) NOT NULL,
    "SOURCE_ENTITY" VARCHAR(255) NOT NULL,
    FOREIGN KEY("PAYMENT_PROVIDER_ID") REFERENCES BL_3NF.CE_PAYMENT_PROVIDERS("PAYMENT_PROVIDER_ID"),
    FOREIGN KEY("PAYMENT_METHOD_ID") REFERENCES BL_3NF.CE_PAYMENT_METHODS("PAYMENT_METHOD_ID"));
    COMMIT;
    ALTER TABLE IF EXISTS BL_3NF.CE_PAYMENTS
    DROP CONSTRAINT IF EXISTS unique_payments_source_triplet;
    ALTER TABLE IF EXISTS BL_3NF.CE_PAYMENTS
    ADD CONSTRAINT unique_payments_source_triplet
    UNIQUE("PAYMENT_SRC_ID","SOURCE_SYSTEM","SOURCE_ENTITY");
    COMMIT;
        --DEFAULT ROW
 INSERT INTO BL_3NF.CE_PAYMENTS
 SELECT -1,-1,-1,-1,-1,'1900-01-01'::timestamp,'MANUAL','MANUAL'
 WHERE NOT EXISTS (SELECT * FROM BL_3NF.CE_PAYMENTS WHERE "PAYMENT_ID" =-1);
 COMMIT;
    

--CE_CUSTOMERS_SCD
 CREATE SEQUENCE IF NOT EXISTS BL_3NF.CE_CUSTOMERS_SEQ START 1;
  CREATE TABLE IF NOT EXISTS BL_3NF.CE_CUSTOMERS_SCD(
    "CUSTOMER_ID" BIGINT PRIMARY KEY,
    "CUSTOMER_SRC_ID" bigint NOT NULL,
    "CUSTOMER_FIRST_NAME" VARCHAR(255)  NOT NULL,
    "CUSTOMER_LAST_NAME" VARCHAR(255) NOT NULL,
    "COUNTRY_ID" BIGINT NOT NULL,
    "LOYALTY_MEMBER" BOOLEAN NOT NULL,
    "LOYALTY_DISCOUNT" DECIMAL(8,2) NOT NULL,
    "GENDER" VARCHAR(255) NOT NULL,
    "BIRTH_YEAR" BIGINT NOT NULL,
    "SIGNUP_DT" DATE NOT NULL,
    "START_DT" TIMESTAMP NOT NULL,
    "END_DT" TIMESTAMP NOT NULL,
    "IS_ACTIVE" BOOLEAN NOT NULL,
    "TA_INSERT_DT" TIMESTAMP NOT NULL,
    "SOURCE_SYSTEM" VARCHAR(255) NOT NULL,
    "SOURCE_ENTITY" VARCHAR(255) NOT NULL,
    FOREIGN KEY("COUNTRY_ID") REFERENCES BL_3NF.CE_COUNTRIES("COUNTRY_ID"));
    COMMIT;
    ALTER TABLE IF EXISTS BL_3NF.CE_CUSTOMERS_SCD 
    DROP CONSTRAINT IF EXISTS unique_customers_scd_customer_id_start_dt;
    ALTER TABLE IF EXISTS BL_3NF.CE_CUSTOMERS_SCD
    ADD CONSTRAINT unique_customers_scd_customer_id_start_dt
    UNIQUE("CUSTOMER_ID","START_DT");
    COMMIT;
    --DEFAULT ROW
    INSERT INTO BL_3NF.CE_CUSTOMERS_SCD
    SELECT -1,-1,'n.a.','n.a.',-1,FALSE,-1,'n.a.',-1,'1900-01-01'::date, '1900-01-01'::timestamp,'9999-01-01'::timestamp,TRUE,'1900-01-01'::timestamp,'MANUAL','MANUAL'
    WHERE NOT EXISTS (SELECT 1 FROM BL_3NF.CE_CUSTOMERS_SCD WHERE "CUSTOMER_ID" =-1);
	COMMIT; 


--CE_SALES
CREATE SEQUENCE IF NOT EXISTS BL_3NF.CE_SALES_SEQ START 1;
 CREATE TABLE IF NOT EXISTS BL_3NF.CE_SALES(
    "SALE_ID" BIGINT PRIMARY KEY,
    "SALE_SRC_ID" VARCHAR(100) NOT NULL,
    "CUSTOMER_ID" BIGINT  NOT NULL,
    "STAFF_ID" BIGINT NOT NULL,
    "STORE_ID" BIGINT NOT NULL,
    "PAYMENT_ID" BIGINT NOT NULL,
    "MANAGER_ID" BIGINT NOT NULL,
    "PRODUCT_ID" BIGINT NOT NULL,
    "EVENT_DT" BIGINT NOT NULL,
    "QUANTITY" INT NOT NULL,
    "LINE_ITEM_AMOUNT" DECIMAL(8,2) NOT NULL,
    "COST" DECIMAL(8,2) NOT NULL,
    "PROFIT" DECIMAL(8,2) NOT NULL,
    "PROFIT_MARGIN" DECIMAL(8,2) NOT NULL,
    "DELIVERY_FEE" DECIMAL(8,2) NOT NULL,
    "TA_INSERT_DT" TIMESTAMP NOT NULL,
    "SOURCE_SYSTEM" VARCHAR(150) NOT NULL,
    "SOURCE_ENTITY" VARCHAR(150) NOT NULL,
    FOREIGN KEY("CUSTOMER_ID") REFERENCES BL_3NF.CE_CUSTOMERS_SCD("CUSTOMER_ID"),
    FOREIGN KEY("STAFF_ID") REFERENCES BL_3NF.CE_STAFF("STAFF_ID"),
    FOREIGN KEY("STORE_ID") REFERENCES BL_3NF.CE_STORES("STORE_ID"),
    FOREIGN KEY("MANAGER_ID") REFERENCES BL_3NF.CE_STAFF("STAFF_ID"),
    FOREIGN KEY("PAYMENT_ID") REFERENCES BL_3NF.CE_PAYMENTS("PAYMENT_ID"),
    FOREIGN KEY ("PRODUCT_ID") REFERENCES BL_3NF.CE_PRODUCTS("PRODUCT_ID"));
 	 COMMIT;
    ALTER TABLE IF EXISTS BL_3NF.CE_SALES
    DROP CONSTRAINT IF EXISTS unique_sales_source_triplet;
    ALTER TABLE IF EXISTS BL_3NF.CE_SALES
    ADD CONSTRAINT unique_sales_source_triplet
    UNIQUE("SALE_SRC_ID","SOURCE_SYSTEM","SOURCE_ENTITY");
    COMMIT;
	INSERT INTO BL_3NF.ce_sales 
	SELECT  -1,'n.a.',-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,'1900-01-01'::timestamp,'MANUAL','MANUAL'
	WHERE NOT EXISTS(SELECT 1 FROM BL_3NF.ce_sales WHERE "SALE_ID"=-1);
--------------------------------------------
--DM TABLES CREATION
CREATE SCHEMA IF NOT EXISTS BL_DM;

--DIM_PAYMENTS
  CREATE SEQUENCE IF NOT EXISTS BL_DM.DIM_PAYMENTS_SEQ START 1;
    CREATE TABLE IF NOT EXISTS BL_DM.DIM_PAYMENTS(
    "PAYMENT_SURR_ID" BIGINT PRIMARY KEY,
    "PAYMENT_SOURCE_ID" BIGINT NOT NULL,
    "PAYMENT_METHOD_ID" BIGINT NOT NULL,
    "PAYMENT_METHOD_DESC" VARCHAR(255) NOT NULL,
    "PAYMENT_PROVIDER_ID" BIGINT NOT NULL,
    "PAYMENT_PROVIDER_DESC" VARCHAR(255) NOT NULL,
    "TRANSACTION_FEE" DECIMAL(8,2) NOT NULL,
    "TA_INSERT_DT" TIMESTAMP NOT NULL,
    "TA_UPDATE_DT" TIMESTAMP NOT NULL,
    "SOURCE_SYSTEM" VARCHAR(255) NOT NULL,
    "SOURCE_ENTITY" VARCHAR(255) NOT NULL
    );
     COMMIT;
    ALTER TABLE IF EXISTS BL_DM.DIM_PAYMENTS
    DROP CONSTRAINT IF EXISTS  unique_payments_source_triplet;
   ALTER TABLE IF EXISTS BL_DM.DIM_PAYMENTS
    ADD CONSTRAINT  unique_payments_source_triplet
    UNIQUE("PAYMENT_SOURCE_ID","SOURCE_SYSTEM","SOURCE_ENTITY");
    COMMIT;
--DEFAULT ROW
	 INSERT INTO BL_DM.DIM_PAYMENTS
	 SELECT -1,-1,-1,'n.a.',-1,'n.a.',-1,'1900-01-01'::timestamp,'1900-01-01'::timestamp,'MANUAL','MANUAL'
	 WHERE NOT EXISTS (SELECT 1 FROM BL_DM.DIM_PAYMENTS WHERE "PAYMENT_SURR_ID" =-1);
	 COMMIT;

--DIM_PRODUCTS
CREATE SEQUENCE IF NOT EXISTS BL_DM.DIM_PRODUCTS_SEQ START 1;
    CREATE TABLE IF NOT EXISTS BL_DM.DIM_PRODUCTS (
    "PRODUCT_SURR_ID" BIGINT PRIMARY KEY,
    "PRODUCT_SOURCE_ID" BIGINT NOT NULL,
    "PRODUCT_DESC" VARCHAR(150) NOT NULL,
    "PRODUCT_TYPE_ID" BIGINT NOT NULL,
    "PRODUCT_TYPE_DESC" VARCHAR(150) NOT NULL,
    "PRODUCT_CATEGORY_ID" BIGINT NOT NULL,
    "PRODUCT_CATEGORY_DESC" VARCHAR(200) NOT NULL,
    "PRODUCT_GROUP_ID" BIGINT NOT NULL,
    "PRODUCT_GROUP_DESC" VARCHAR(200) NOT NULL,
    "PROMO_FLAG" BOOLEAN NOT NULL,
    "PROMO_DISCOUNT" DECIMAL(6,2) NOT NULL,
    "BASE_PRICE" DECIMAL(12,2) NOT NULL,
    "IS_LIMITED_EDITION" BOOLEAN NOT NULL,
    "TA_INSERT_DT" TIMESTAMP NOT NULL,
    "TA_UPDATE_DT" TIMESTAMP NOT NULL,
    "SOURCE_SYSTEM" VARCHAR(150) NOT NULL,
    "SOURCE_ENTITY" VARCHAR(150) NOT NULL);
    COMMIT;
    ALTER TABLE IF EXISTS BL_DM.DIM_PRODUCTS
    DROP CONSTRAINT IF EXISTS  unique_products_source_triplet;
    ALTER TABLE IF EXISTS BL_DM.DIM_PRODUCTS
    ADD CONSTRAINT  unique_products_source_triplet
    UNIQUE("PRODUCT_SOURCE_ID","SOURCE_SYSTEM","SOURCE_ENTITY");
    COMMIT;
       --DEFAULT ROW
    INSERT INTO BL_DM.DIM_PRODUCTS
    SELECT -1,-1,'n.a.',-1,'n.a',-1, 'n.a.', -1,'n.a.',FALSE,-1,-1,FALSE,'1900-01-01'::timestamp,'1900-01-01'::timestamp,'MANUAL','MANUAL'
    WHERE NOT EXISTS(SELECT 1 FROM BL_DM.DIM_PRODUCTS WHERE "PRODUCT_SURR_ID"=-1 );
	COMMIT;

--DIM_STORES
CREATE SEQUENCE IF NOT EXISTS BL_DM.DIM_STORES_SEQ START 1;
    CREATE TABLE IF NOT EXISTS BL_DM.DIM_STORES(
    "STORE_SURR_ID" BIGINT PRIMARY KEY,
    "STORE_SOURCE_ID" BIGINT NOT NULL,
    "STORE_DESC" VARCHAR(150) NOT NULL,
    "WEBSITE" VARCHAR(150) NOT NULL,
    "CITY_ID" BIGINT NOT NULL,
    "CITY_DESC" VARCHAR(255) NOT NULL,
    "COUNTRY_ID" BIGINT NOT NULL,
    "COUNTRY_DESC" VARCHAR(100) NOT NULL,
    "STORE_ADDRESS" VARCHAR(255) NOT NULL,
    "STORE_TYPE" VARCHAR(100) NOT NULL,
    "TA_INSERT_DT" TIMESTAMP NOT NULL,
    "TA_UPDATE_DT" TIMESTAMP NOT NULL,
    "SOURCE_SYSTEM" VARCHAR(150) NOT NULL,
    "SOURCE_ENTITY" VARCHAR(150) NOT NULL
    );
    COMMIT;
    ALTER TABLE IF EXISTS BL_DM.DIM_STORES
    DROP CONSTRAINT IF  EXISTS unique_stores_source_triplet;
    ALTER TABLE IF EXISTS BL_DM.DIM_STORES
    ADD CONSTRAINT unique_stores_source_triplet
    UNIQUE("STORE_SOURCE_ID","SOURCE_SYSTEM","SOURCE_ENTITY");
    COMMIT;
    --DEFAULT ROW
   INSERT INTO BL_DM.DIM_STORES
   SELECT -1,-1,'n.a','n.a.',-1,'n.a',-1,'n.a','n.a','n.a','1900-01-01'::timestamp,'1900-01-01'::timestamp,'MANUAL','MANUAL'
   WHERE NOT EXISTS (SELECT 1 FROM BL_DM.DIM_STORES WHERE "STORE_SURR_ID" =-1);
   COMMIT;


--DIM_DATES
CREATE TABLE IF NOT EXISTS BL_DM.DIM_DATES (
	"DATE_ID" BIGINT PRIMARY KEY, -- FOR EXAMPLE 20240701 IS FOR 2024-07-01
	"DAY_OF_WEEK" VARCHAR(255) NOT NULL, -- MONDAY, THUESDAY...
	"DAY_OF_MONTH" INT NOT NULL, -- 1,2,3,4,..,,31
	"WEEK_ID" BIGINT NOT NULL, --202414 14TH WEEK OF 2024
	"MONTH_ID" BIGINT NOT NULL, --202407 FOR JULY 2024 YEAR
	"MONTH_DESC" VARCHAR(255) NOT NULL, -- JULE,JUNE etc
	"QUARTER_ID" INT NOT NULL, --1,2,3,4
	"QUARTER_DESC" VARCHAR(255) NOT NULL, --Q1,Q2,Q3,Q4
	"YEAR_ID" BIGINT NOT NULL,--2024 2023 FOR EXAMPLE
	"IS_WEEKEND" BOOLEAN NOT NULL --IF ITS WEEKEND THE VALUE IS TRUE OTHERWISE FALSE
	);
	COMMIT;
INSERT INTO  BL_DM.DIM_DATES
SELECT -1,'n.a.',-1,-1,-1,'n.a.',-1,'n.a.',-1,FALSE
WHERE NOT EXISTS (SELECT 1 FROM  BL_DM.DIM_DATES WHERE "DATE_ID"=-1);
--DIM_CUSTOMERS_SCD
--DROP TABLE BL_DM.DIM_CUSTOMERS_SCD CASCADE;
 CREATE SEQUENCE IF NOT EXISTS BL_DM.DIM_CUSTOMERS_SCD_SEQ START 1;
    CREATE TABLE IF NOT EXISTS BL_DM.DIM_CUSTOMERS_SCD(
    "CUSTOMER_SURR_ID" BIGINT PRIMARY KEY,
    "CUSTOMER_SOURCE_ID" BIGINT  NOT NULL,
    "CUSTOMER_FIRST_NAME" VARCHAR(150) NOT NULL,
    "CUSTOMER_LAST_NAME" VARCHAR(150) NOT NULL,
    "COUNTRY_ID" BIGINT NOT NULL,
    "COUNTRY_DESC" VARCHAR(100) NOT NULL,
    "LOYALTY_MEMBER" BOOLEAN NOT NULL,
    "LOYALTY_DISCOUNT" DECIMAL(8,2) NOT NULL,
    "GENDER" VARCHAR(15) NOT NULL,
    "BIRTH_YEAR" INT NOT NULL,
    "SIGNUP_DT" DATE NOT NULL,
    "START_DT" TIMESTAMP NOT NULL,
    "END_DT" TIMESTAMP NOT NULL,
    "IS_ACTIVE" BOOLEAN NOT NULL,
    "TA_INSERT_DT" TIMESTAMP NOT NULL,
    "TA_UPDATE_DT" TIMESTAMP NOT NULL,
    "SOURCE_SYSTEM" VARCHAR(150) NOT NULL,
    "SOURCE_ENTITY" VARCHAR(150) NOT NULL);
     COMMIT;
    ALTER TABLE IF EXISTS BL_DM.DIM_CUSTOMERS_SCD
    DROP CONSTRAINT IF EXISTS  unique_customers_scd_source_triplet;
    ALTER TABLE IF EXISTS BL_DM.DIM_CUSTOMERS_SCD
    ADD CONSTRAINT  unique_customers_scd_source_triplet
    UNIQUE("CUSTOMER_SOURCE_ID","SOURCE_SYSTEM","SOURCE_ENTITY");
    COMMIT;
--default row
  	 INSERT INTO BL_DM.DIM_CUSTOMERS_SCD
	 SELECT -1,-1,'n.a.','n.a.',-1,'n.a.',FALSE,-1,'n.a.',-1,'1900-01-01'::DATE,'1900-01-01'::timestamp,'9999-01-01'::timestamp,TRUE,'1900-01-01'::timestamp,'1900-01-01'::timestamp,'MANUAL','MANUAL'
	 WHERE NOT EXISTS (SELECT 1 FROM BL_DM.DIM_CUSTOMERS_SCD WHERE "CUSTOMER_SURR_ID" =-1);
  	 COMMIT;

--DIM_STAFF
CREATE SEQUENCE IF NOT EXISTS BL_DM.DIM_STAFF_SEQ START 1;
    CREATE TABLE IF NOT EXISTS BL_DM.DIM_STAFF(
    "STAFF_SURR_ID" BIGINT PRIMARY KEY,
    "STAFF_SOURCE_ID" BIGINT  NOT NULL,
    "STAFF_FIRST_NAME" VARCHAR(255) NOT NULL,
    "STAFF_LAST_NAME" VARCHAR(255) NOT NULL,
    "JOB_START_DT" DATE NOT NULL,
    "EMPLOYMENT_STATUS" VARCHAR(255) NOT NULL,
    "HOURLY_WAGE" DECIMAL(10,2) NOT NULL,  
    "JOB_ID" BIGINT NOT NULL,
    "JOB_DESC" VARCHAR(255) NOT NULL,
    "TA_INSERT_DT" TIMESTAMP NOT NULL,
    "TA_UPDATE_DT" TIMESTAMP NOT NULL,
    "SOURCE_SYSTEM" VARCHAR(255) NOT NULL,
    "SOURCE_ENTITY" VARCHAR(255) NOT NULL);
   COMMIT;
   ALTER TABLE IF EXISTS BL_DM.DIM_STAFF
    DROP CONSTRAINT IF EXISTS  unique_staff_source_triplet;
   ALTER TABLE IF EXISTS BL_DM.DIM_STAFF
    ADD CONSTRAINT  unique_staff_source_triplet
    UNIQUE("STAFF_SOURCE_ID","SOURCE_SYSTEM","SOURCE_ENTITY");
    COMMIT;
  --DEFAULT ROW
   INSERT INTO BL_DM.DIM_STAFF
   SELECT -1,-1,'n.a.','n.a.','1900-01-01'::date,'n.a.',-1,-1,'n.a.','1900-01-01'::timestamp,'1900-01-01'::timestamp,'MANUAL','MANUAL'
   WHERE NOT EXISTS (SELECT 1 FROM BL_DM.DIM_STAFF WHERE "STAFF_SURR_ID" =-1);
   COMMIT ;


--FCT_SALES_DD
CREATE SEQUENCE IF NOT EXISTS BL_DM.FCT_SALES_DD_SEQ START 1;
CREATE TABLE IF NOT EXISTS BL_DM.FCT_SALES_DD(
"SALE_SURR_ID" BIGINT ,
"SALE_ID" VARCHAR(100) NOT NULL, 
"SALE_SOURCE_ID" BIGINT NOT NULL,
"CUSTOMER_ID" BIGINT NOT NULL,
"STAFF_ID" BIGINT NOT NULL,
"STORE_ID" BIGINT NOT NULL,
"PAYMENT_ID" BIGINT NOT NULL,
"MANAGER_ID" BIGINT NOT NULL,
"PRODUCT_ID" BIGINT NOT NULL,
"EVENT_DT" BIGINT NOT NULL,
"QUANTITY" INT NOT NULL,
"LINE_ITEM_AMOUNT" DECIMAL(8,2) NOT NULL,
"COST" DECIMAL(8,2) NOT NULL,
"PROFIT" DECIMAL(8,2) NOT NULL,
"PROFIT_MARGIN" DECIMAL(8,2) NOT NULL,
"DELIVERY_FEE" DECIMAL(8,2) NOT NULL,
"TA_INSERT_DT" TIMESTAMP NOT NULL,
"TA_UPDATE_DT" TIMESTAMP NOT NULL,
"SOURCE_SYSTEM" VARCHAR(150) NOT NULL,
"SOURCE_ENTITY" VARCHAR(150) NOT NULL,
FOREIGN KEY("CUSTOMER_ID") REFERENCES BL_DM.DIM_CUSTOMERS_SCD("CUSTOMER_SURR_ID"),
FOREIGN KEY("STAFF_ID") REFERENCES BL_DM.DIM_STAFF("STAFF_SURR_ID"),
FOREIGN KEY("STORE_ID") REFERENCES BL_DM.DIM_STORES("STORE_SURR_ID"),
FOREIGN KEY("MANAGER_ID") REFERENCES BL_DM.DIM_STAFF("STAFF_SURR_ID"),
FOREIGN KEY("PAYMENT_ID") REFERENCES BL_DM.DIM_PAYMENTS("PAYMENT_SURR_ID"),
FOREIGN KEY("PRODUCT_ID") REFERENCES BL_DM.DIM_PRODUCTS("PRODUCT_SURR_ID"),
CONSTRAINT PK_SURR_ID_EVENT_DT PRIMARY KEY ( "SALE_SURR_ID", "EVENT_DT" )
) PARTITION BY RANGE ("EVENT_DT");
COMMIT;
ALTER TABLE IF EXISTS BL_DM.FCT_SALES_DD
DROP CONSTRAINT IF EXISTS unique_sales_source_triplet_event_dt;
ALTER TABLE IF EXISTS BL_DM.FCT_SALES_DD
ADD CONSTRAINT unique_sales_source_triplet_event_dt
UNIQUE("EVENT_DT","SALE_SOURCE_ID","SOURCE_SYSTEM","SOURCE_ENTITY");
COMMIT;

----------------------------------------------------------------------
--PROCEDURE CREATION
--LOGGING PROCEDURE FOR 3NF
CREATE SEQUENCE IF NOT EXISTS BL_CL.ETL_LOG_SEQ START 1;
CREATE OR REPLACE PROCEDURE BL_CL.LOG_ETL(
    P_PROCEDURE_NAME VARCHAR,
    P_ROWS_AFFECTED INT,
    P_MESSAGE TEXT)
LANGUAGE PLPGSQL 
AS
$$
BEGIN
    INSERT INTO BL_CL.ETL_LOG(ID,PROCEDURE_NAME, ROWS_AFFECTED, MESSAGE)
    VALUES (NEXTVAL('BL_CL.ETL_LOG_SEQ'),P_PROCEDURE_NAME, P_ROWS_AFFECTED, P_MESSAGE);
END;
$$;
COMMIT;

--LOGGING PROCEDURE FOR DIM
CREATE SEQUENCE IF NOT EXISTS BL_CL.ETL_LOG_DM_SEQ START 1;
CREATE OR REPLACE PROCEDURE BL_CL.LOG_ETL_DM(
    P_PROCEDURE_NAME VARCHAR,
    P_ROWS_AFFECTED INT,
    P_MESSAGE TEXT)
LANGUAGE PLPGSQL AS
$$
BEGIN
    INSERT INTO BL_CL.ETL_LOG_DM(ID, PROCEDURE_NAME, ROWS_AFFECTED, MESSAGE)
    VALUES (NEXTVAL('BL_CL.ETL_LOG_DM_SEQ'), P_PROCEDURE_NAME, P_ROWS_AFFECTED, P_MESSAGE);
END;
$$;

--LOAD_CE_PRODUCT_GROUPS
CREATE OR REPLACE PROCEDURE BL_CL.LOAD_CE_PRODUCT_GROUPS()
LANGUAGE PLPGSQL
AS
$$
DECLARE
    ROWS_INSERTED INTEGER := 0;
BEGIN
    INSERT INTO BL_3NF.CE_PRODUCT_GROUPS (
        "PRODUCT_GROUP_ID",
        "PRODUCT_GROUP_SRC_ID",
        "PRODUCT_GROUP_DESC",
        "TA_INSERT_DT",
        "SOURCE_SYSTEM",
        "SOURCE_ENTITY" )
    SELECT 
        NEXTVAL('BL_3NF.CE_PRODUCT_GROUPS_SEQ'),
        PG."PRODUCT_GROUP",
        PG."PRODUCT_GROUP",
        CURRENT_TIMESTAMP,
        PG."SOURCE_SYSTEM",
        PG."SOURCE_ENTITY"
    FROM ( 
        SELECT DISTINCT
            "PRODUCT_GROUP",
            'SA_ONLINE_SALES' AS "SOURCE_SYSTEM",
            'SRC_ONLINE_COFFEE_SHOP_TRANSACTIONS' AS "SOURCE_ENTITY"
        FROM SA_ONLINE_SALES.SRC_ONLINE_COFFEE_SHOP_TRANSACTIONS
        UNION ALL
        SELECT DISTINCT
            "PRODUCT_GROUP",
            'SA_OFFLINE_SALES' AS "SOURCE_SYSTEM",
            'SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS' AS "SOURCE_ENTITY"
        FROM SA_OFFLINE_SALES.SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS
    ) PG
    ON CONFLICT("PRODUCT_GROUP_SRC_ID", "SOURCE_ENTITY", "SOURCE_SYSTEM") 
    DO NOTHING;
    GET DIAGNOSTICS ROWS_INSERTED = ROW_COUNT;
      CALL BL_CL.LOG_ETL('LOAD_CE_PRODUCT_GROUPS', ROWS_INSERTED, 'SUCCESS');
EXCEPTION  WHEN OTHERS THEN
            CALL BL_CL.LOG_ETL('LOAD_CE_PRODUCT_GROUP', 0, 'ERROR: ' || SQLERRM);
END;
$$;

--LOAD_CE_PRODUCT_CATEGORIES

CREATE OR REPLACE PROCEDURE BL_CL.LOAD_CE_PRODUCT_CATEGORIES()
LANGUAGE PLPGSQL
AS 
$$
DECLARE
    ROWS_INSERTED INTEGER := 0;
BEGIN
	INSERT INTO BL_3NF.CE_PRODUCT_CATEGORIES (
    "PRODUCT_CATEGORY_ID",
    "PRODUCT_CATEGORY_SRC_ID",
    "PRODUCT_GROUP_ID",
    "PRODUCT_CATEGORY_DESC",
    "TA_INSERT_DT",
    "SOURCE_SYSTEM",
    "SOURCE_ENTITY")
SELECT DISTINCT
    NEXTVAL('BL_3NF.CE_PRODUCT_CATEGORIES_SEQ'),
    PC."PRODUCT_CATEGORY" || ' | ' || PC."PRODUCT_GROUP",
    COALESCE(PG."PRODUCT_GROUP_ID", -1),
    PC."PRODUCT_CATEGORY",
    CURRENT_TIMESTAMP,
    PC."SOURCE_SYSTEM",
    PC."SOURCE_ENTITY"
FROM (
    SELECT DISTINCT
        "PRODUCT_CATEGORY" AS "PRODUCT_CATEGORY",
        "PRODUCT_GROUP" AS "PRODUCT_GROUP",
        'SA_ONLINE_SALES' AS "SOURCE_SYSTEM",
        'SRC_ONLINE_COFFEE_SHOP_TRANSACTIONS' AS "SOURCE_ENTITY"
    FROM SA_ONLINE_SALES.SRC_ONLINE_COFFEE_SHOP_TRANSACTIONS
    UNION ALL
    SELECT DISTINCT
        "PRODUCT_CATEGORY" AS "PRODUCT_CATEGORY",
       "PRODUCT_GROUP" AS "PRODUCT_GROUP",
        'SA_OFFLINE_SALES' AS "SOURCE_SYSTEM",
        'SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS' AS "SOURCE_ENTITY"
    FROM SA_OFFLINE_SALES.SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS) PC
LEFT JOIN BL_3NF.CE_PRODUCT_GROUPS PG 
ON PG."PRODUCT_GROUP_SRC_ID" = PC."PRODUCT_GROUP" AND PG."SOURCE_SYSTEM"=PC."SOURCE_SYSTEM" AND PG."SOURCE_ENTITY"=PC."SOURCE_ENTITY"
ON CONFLICT ("PRODUCT_CATEGORY_SRC_ID","SOURCE_SYSTEM","SOURCE_ENTITY") DO 
NOTHING;
GET DIAGNOSTICS ROWS_INSERTED = ROW_COUNT;
CALL BL_CL.LOG_ETL('LOAD_CE_PRODUCT_CATEGORIES', ROWS_INSERTED, 'SUCCESS');
EXCEPTION  WHEN OTHERS THEN
 CALL BL_CL.LOG_ETL('LOAD_CE_PRODUCT_CATEGORIES', 0, 'ERROR: ' || SQLERRM);
END;
$$;


--LOAD_CE_PRODUCT_TYPES
CREATE OR REPLACE PROCEDURE  BL_CL.LOAD_CE_PRODUCT_TYPES()
LANGUAGE PLPGSQL
AS
$$
DECLARE
    ROWS_INSERTED INTEGER := 0;
BEGIN 
	INSERT INTO BL_3NF.CE_PRODUCT_TYPES (
    "PRODUCT_TYPE_ID",
    "PRODUCT_TYPE_SRC_ID",
    "PRODUCT_CATEGORY_ID" ,
    "PRODUCT_TYPE_DESC",
    "TA_INSERT_DT" ,
    "SOURCE_SYSTEM",
    "SOURCE_ENTITY")
SELECT 
    NEXTVAL('BL_3NF.CE_PRODUCT_TYPES_SEQ'),
  	PT."PRODUCT_TYPE_SRC_ID",
    COALESCE(PC."PRODUCT_CATEGORY_ID", -1),
    PT."PRODUCT_TYPE",
    CURRENT_TIMESTAMP,
    PT."SOURCE_SYSTEM",
    PT."SOURCE_ENTITY"
FROM (
    SELECT DISTINCT
       "PRODUCT_TYPE" AS "PRODUCT_TYPE",
       "PRODUCT_CATEGORY" AS "PRODUCT_CATEGORY",
       "PRODUCT_TYPE"|| ' | ' || "PRODUCT_CATEGORY" || ' | ' || "PRODUCT_GROUP" AS "PRODUCT_TYPE_SRC_ID",
       "PRODUCT_GROUP" AS "PRODUCT_GROUP",
        'SA_ONLINE_SALES' AS "SOURCE_SYSTEM",
        'SRC_ONLINE_COFFEE_SHOP_TRANSACTIONS' AS "SOURCE_ENTITY"
    FROM SA_ONLINE_SALES.SRC_ONLINE_COFFEE_SHOP_TRANSACTIONS
    UNION ALL
    SELECT DISTINCT
       "PRODUCT_TYPE" AS "PRODUCT_TYPE",
       "PRODUCT_CATEGORY" AS "PRODUCT_CATEGORY",
       "PRODUCT_TYPE" || ' | ' || "PRODUCT_CATEGORY" || ' | ' || "PRODUCT_GROUP" AS "PRODUCT_TYPE_SRC_ID",
       "PRODUCT_GROUP" AS "PRODUCT_GROUP",
        'SA_OFFLINE_SALES' AS "SOURCE_SYSTEM",
        'SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS' AS "SOURCE_ENTITY"
    FROM SA_OFFLINE_SALES.SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS
) PT
LEFT JOIN BL_3NF.CE_PRODUCT_CATEGORIES PC 
ON PC."PRODUCT_CATEGORY_SRC_ID" =PT."PRODUCT_CATEGORY"|| ' | ' || PT."PRODUCT_GROUP" AND PC."SOURCE_SYSTEM"=PT."SOURCE_SYSTEM" AND PC."SOURCE_ENTITY"=PT."SOURCE_ENTITY"
ON CONFLICT("PRODUCT_TYPE_SRC_ID","SOURCE_ENTITY","SOURCE_SYSTEM") DO 
NOTHING;
GET DIAGNOSTICS ROWS_INSERTED = ROW_COUNT;
 CALL BL_CL.LOG_ETL('LOAD_CE_PRODUCT_TYPES', ROWS_INSERTED, 'SUCCESS');
EXCEPTION  WHEN OTHERS THEN
           CALL BL_CL.LOG_ETL('LOAD_CE_PRODUCT_TYPES', 0, 'ERROR: ' || SQLERRM);
END;
$$;

--LOAD_CE_PRODUCTS

CREATE OR REPLACE PROCEDURE BL_CL.LOAD_CE_PRODUCTS()
LANGUAGE PLPGSQL
AS
$$
DECLARE
    ROWS_INSERTED INTEGER := 0;
BEGIN 
with all_products as (
	 SELECT DISTINCT 
           "PRODUCT_ID",
            "PRODUCT_DESC",
            "PROMO_FLAG",
            "PROMO_DISCOUNT",
            "BASE_PRICE",
            "IS_LIMITED_EDITION",
            "PRODUCT_TYPE",
            "PRODUCT_CATEGORY",
            "PRODUCT_GROUP",
            "EVENT_DT"::BIGINT,
            'SA_ONLINE_SALES' AS "SOURCE_SYSTEM",
            'SRC_ONLINE_COFFEE_SHOP_TRANSACTIONS' AS "SOURCE_ENTITY"
        FROM SA_ONLINE_SALES.SRC_ONLINE_COFFEE_SHOP_TRANSACTIONS
        UNION ALL
        SELECT distinct
            "PRODUCT_ID",
            "PRODUCT_DESC",
            "PROMO_FLAG",
            "PROMO_DISCOUNT",
            "BASE_PRICE",
            "IS_LIMITED_EDITION",
            "PRODUCT_TYPE",
            "PRODUCT_CATEGORY",
            "PRODUCT_GROUP",
            "EVENT_DT"::BIGINT,
            'SA_OFFLINE_SALES' AS "SOURCE_SYSTEM",
            'SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS' AS "SOURCE_ENTITY"
        FROM SA_OFFLINE_SALES.SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS),
mapping_joined as (select distinct
						MP."PRODUCT_ID",
			            MP."PRODUCT_DESC",
			            S."PROMO_FLAG",
			            S."PROMO_DISCOUNT",
			            S."BASE_PRICE",
			            S."IS_LIMITED_EDITION",
			            S."PRODUCT_TYPE",
			            S."PRODUCT_CATEGORY",
			            S."PRODUCT_GROUP",
			            S."EVENT_DT"::BIGINT,
						MP."SOURCE_ENTITY",
						MP."SOURCE_SYSTEM"
						from all_products s
					   LEFT JOIN BL_CL.T_MAP_PRODUCTS MP 
				        ON S."PRODUCT_ID" = MP."PRODUCT_SRC_ID"
				       AND S."SOURCE_SYSTEM" = MP."SOURCE_SYSTEM"
				       AND S."SOURCE_ENTITY" = MP."SOURCE_ENTITY"),
ranked_products as (select *, row_number() over (partition by "PRODUCT_ID"  order by "EVENT_DT" DESC) AS rn from mapping_joined)
	INSERT INTO BL_3NF.CE_PRODUCTS (
    "PRODUCT_ID",
    "PRODUCT_SRC_ID",
    "PRODUCT_TYPE_ID",
    "PRODUCT_DESC",
    "PROMO_FLAG",
    "PROMO_DISCOUNT",
    "BASE_PRICE",
    "IS_LIMITED_EDITION",
    "TA_INSERT_DT",
    "SOURCE_SYSTEM",
    "SOURCE_ENTITY"
)
SELECT DISTINCT
    NEXTVAL('BL_3NF.CE_PRODUCTS_SEQ'),                 
    P."PRODUCT_ID",                                     
    COALESCE(PT."PRODUCT_TYPE_ID", -1),                  
    P."PRODUCT_DESC",                                  
    P."PROMO_FLAG"::BOOLEAN,                           
    P."PROMO_DISCOUNT"::DECIMAL(6,2),
    P."BASE_PRICE"::DECIMAL(12,2),
    P."IS_LIMITED_EDITION"::BOOLEAN,
    CURRENT_TIMESTAMP,                                  
    'BL_CL',
    'T_MAP_PRODUCTS'
FROM ranked_products p
LEFT JOIN BL_3NF.CE_PRODUCT_TYPES PT 
  ON PT."PRODUCT_TYPE_SRC_ID" = P."PRODUCT_TYPE" || ' | ' || P."PRODUCT_CATEGORY" || ' | ' || P."PRODUCT_GROUP"
	AND PT."SOURCE_SYSTEM"=P."SOURCE_SYSTEM"
	AND PT."SOURCE_ENTITY"=P."SOURCE_ENTITY"
where rn =1  
ON CONFLICT("PRODUCT_SRC_ID", "SOURCE_SYSTEM", "SOURCE_ENTITY") DO 
UPDATE SET  
    "PRODUCT_TYPE_ID" = excluded."PRODUCT_TYPE_ID",
    "PRODUCT_DESC" = excluded."PRODUCT_DESC",
    "PROMO_FLAG" = excluded."PROMO_FLAG",
    "PROMO_DISCOUNT" = excluded."PROMO_DISCOUNT",
    "BASE_PRICE" = excluded."BASE_PRICE",
    "IS_LIMITED_EDITION" = excluded."IS_LIMITED_EDITION"
WHERE 
    (BL_3NF.CE_PRODUCTS."PRODUCT_TYPE_ID" IS DISTINCT FROM excluded."PRODUCT_TYPE_ID" OR
     BL_3NF.CE_PRODUCTS."PRODUCT_DESC" IS DISTINCT FROM excluded."PRODUCT_DESC" OR
     BL_3NF.CE_PRODUCTS."PROMO_FLAG" IS DISTINCT FROM excluded."PROMO_FLAG" OR
     BL_3NF.CE_PRODUCTS."PROMO_DISCOUNT" IS DISTINCT FROM excluded."PROMO_DISCOUNT" OR
     BL_3NF.CE_PRODUCTS."BASE_PRICE" IS DISTINCT FROM excluded."BASE_PRICE" OR
     BL_3NF.CE_PRODUCTS."IS_LIMITED_EDITION" IS DISTINCT FROM excluded."IS_LIMITED_EDITION");
GET DIAGNOSTICS ROWS_INSERTED = ROW_COUNT;
  CALL BL_CL.LOG_ETL('LOAD_CE_PRODUCTS', ROWS_INSERTED, 'SUCCESS ');
EXCEPTION  WHEN OTHERS THEN
    CALL BL_CL.LOG_ETL('LOAD_CE_PRODUCTS', 0, 'ERROR: ' || SQLERRM);
END;
$$;

--ONLY FUNCTION FOR GETTING COUNTRIES
--FNC_GET_COUNTRIES
CREATE OR REPLACE FUNCTION BL_CL.FNC_GET_COUNTRIES()
RETURNS TABLE ( COUNTRY_SRC_ID VARCHAR,
    COUNTRY_DESC VARCHAR,
    SOURCE_SYSTEM VARCHAR,
    SOURCE_ENTITY VARCHAR)
AS
$$
BEGIN
   RETURN QUERY
   SELECT DISTINCT "STORE_COUNTRY"::VARCHAR,
                    "STORE_COUNTRY"::VARCHAR,
                    'SA_ONLINE_SALES'::VARCHAR,
                    'SRC_ONLINE_COFFEE_SHOP_TRANSACTIONS'::VARCHAR
    FROM SA_ONLINE_SALES.SRC_ONLINE_COFFEE_SHOP_TRANSACTIONS
    UNION all
    SELECT DISTINCT "STORE_COUNTRY"::VARCHAR,
                    "STORE_COUNTRY"::VARCHAR,
                    'SA_OFFLINE_SALES'::VARCHAR,
                    'SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS'::VARCHAR
    FROM SA_OFFLINE_SALES.SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS
    UNION all
    SELECT DISTINCT "CUSTOMER_COUNTRY"::VARCHAR,
                    "CUSTOMER_COUNTRY"::VARCHAR,
                    'SA_OFFLINE_SALES'::VARCHAR,
                    'SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS'::VARCHAR
    FROM SA_OFFLINE_SALES.SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS
    UNION all
    SELECT DISTINCT "CUSTOMER_COUNTRY"::VARCHAR,
                    "CUSTOMER_COUNTRY"::VARCHAR,
                    'SA_ONLINE_SALES'::VARCHAR,
                    'SRC_ONLINE_COFFEE_SHOP_TRANSACTIONS'::VARCHAR
    FROM SA_ONLINE_SALES.SRC_ONLINE_COFFEE_SHOP_TRANSACTIONS;
END;
$$
LANGUAGE PLPGSQL;


--LOAD_CE_COUNTRIES
CREATE OR REPLACE PROCEDURE BL_CL.LOAD_CE_COUNTRIES()
LANGUAGE PLPGSQL AS
$$
DECLARE
    REC RECORD;
    ROWS_INSERTED INT := 0;
BEGIN
    FOR REC IN SELECT * FROM BL_CL.FNC_GET_COUNTRIES() LOOP
        BEGIN
            INSERT INTO BL_3NF.CE_COUNTRIES (
                "COUNTRY_ID",
                "COUNTRY_SRC_ID",
                "COUNTRY_DESC",
                "TA_INSERT_DT",
                "SOURCE_SYSTEM",
                "SOURCE_ENTITY")
            VALUES (NEXTVAL('BL_3NF.CE_COUNTRIES_SEQ'),
                REC.COUNTRY_SRC_ID,
                REC.COUNTRY_DESC,
                CURRENT_TIMESTAMP,
                REC.SOURCE_SYSTEM,
                REC.SOURCE_ENTITY)
            ON CONFLICT ("COUNTRY_SRC_ID", "SOURCE_SYSTEM", "SOURCE_ENTITY") DO NOTHING;
            IF FOUND THEN
                ROWS_INSERTED := ROWS_INSERTED + 1;
            END IF;
        EXCEPTION WHEN OTHERS THEN
        CALL BL_CL.LOG_ETL('LOAD_CE_COUNTRIES', 0, 'ERROR: ' || SQLERRM);
        RAISE;
    END;
    END LOOP;
    CALL BL_CL.LOG_ETL('LOAD_CE_COUNTRIES', ROWS_INSERTED, 'SUCCESS');
END;
$$;

--LOAD_CE_CITIES
CREATE OR REPLACE PROCEDURE BL_CL.LOAD_CE_CITIES()
LANGUAGE PLPGSQL
AS $$
DECLARE ROWS_INSERTED INTEGER := 0;
BEGIN 
	INSERT INTO BL_3NF.CE_CITIES (
    "CITY_ID",
    "CITY_SRC_ID",
    "COUNTRY_ID",
    "CITY_DESC",
    "TA_INSERT_DT",
    "SOURCE_SYSTEM",
    "SOURCE_ENTITY")
SELECT 
    NEXTVAL('BL_3NF.CE_CITIES_SEQ'),
    CI."CITY" || ' | ' || CI."COUNTRY" AS "CITY_SRC_ID",
    COALESCE(C."COUNTRY_ID", -1),
    CI."CITY",
    CURRENT_TIMESTAMP,
    CI."SOURCE_SYSTEM",
    CI."SOURCE_ENTITY"
FROM ( SELECT DISTINCT 
       "STORE_CITY" AS "CITY",
       "STORE_COUNTRY" AS "COUNTRY",
        'SA_ONLINE_SALES' AS "SOURCE_SYSTEM",
        'SRC_ONLINE_COFFEE_SHOP_TRANSACTIONS' AS "SOURCE_ENTITY"
    FROM SA_ONLINE_SALES.SRC_ONLINE_COFFEE_SHOP_TRANSACTIONS
    UNION ALL
    SELECT DISTINCT 
       "STORE_CITY" AS "CITY",
      "STORE_COUNTRY" AS "COUNTRY",
        'SA_OFFLINE_SALES' AS "SOURCE_SYSTEM",
        'SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS' AS "SOURCE_ENTITY"
    FROM SA_OFFLINE_SALES.SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS) CI
LEFT JOIN BL_3NF.CE_COUNTRIES C 
ON LOWER(C."COUNTRY_SRC_ID") = LOWER(CI."COUNTRY") AND C."SOURCE_SYSTEM"=CI."SOURCE_SYSTEM" AND C."SOURCE_ENTITY"=CI."SOURCE_ENTITY"
ON CONFLICT ("CITY_SRC_ID","SOURCE_SYSTEM","SOURCE_ENTITY") DO NOTHING;
GET DIAGNOSTICS ROWS_INSERTED = ROW_COUNT;
  CALL BL_CL.LOG_ETL('LOAD_CE_CITIES', ROWS_INSERTED, 'SUCCESS' );
EXCEPTION  WHEN OTHERS THEN
          CALL BL_CL.LOG_ETL('LOAD_CE_CITIES', 0, 'ERROR: ' || SQLERRM);
END;
$$;

--LOAD_CE_JOBS
CREATE OR REPLACE PROCEDURE BL_CL.LOAD_CE_JOBS()
LANGUAGE PLPGSQL
AS
$$
DECLARE ROWS_INSERTED INTEGER:=0;
BEGIN
	INSERT INTO BL_3NF.CE_JOBS (
    "JOB_ID",
    "JOB_SRC_ID",
    "JOB_DESC",
    "TA_INSERT_DT",
    "SOURCE_SYSTEM",
    "SOURCE_ENTITY")
SELECT 
    NEXTVAL('BL_3NF.CE_JOBS_SEQ'),
    J."STAFF_JOB_DESC",
    J."STAFF_JOB_DESC",
    CURRENT_TIMESTAMP,
    'SA_OFFLINE_SALES',
    'SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS'
FROM (
    SELECT DISTINCT "STAFF_JOB_DESC" AS "STAFF_JOB_DESC"
    FROM SA_OFFLINE_SALES.SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS
) J
ON CONFLICT ("JOB_SRC_ID","SOURCE_SYSTEM","SOURCE_ENTITY") DO NOTHING;
GET DIAGNOSTICS ROWS_INSERTED = ROW_COUNT;
      CALL BL_CL.LOG_ETL('LOAD_CE_JOBS', ROWS_INSERTED, 'SUCCESS');
EXCEPTION  WHEN OTHERS THEN
       CALL BL_CL.LOG_ETL('LOAD_CE_JOBS', 0, 'ERROR: ' || SQLERRM);
END;
$$;

--CE_LOAD_PAYMENT_METHODS
CREATE OR REPLACE PROCEDURE BL_CL.LOAD_CE_PAYMENT_METHODS()
LANGUAGE PLPGSQL
AS $$
DECLARE ROWS_INSERTED INTEGER =0;
BEGIN
	INSERT INTO BL_3NF.CE_PAYMENT_METHODS (
    "PAYMENT_METHOD_ID",
    "PAYMENT_METHOD_SRC_ID",
    "PAYMENT_METHOD_DESC",
    "IS_CONTACTLESS",
    "TA_INSERT_DT",
    "SOURCE_SYSTEM",
    "SOURCE_ENTITY")
SELECT 
    NEXTVAL('BL_3NF.CE_PAYMENT_METHODS_SEQ'),
    PM."PAYMENT_METHOD",
    PM."PAYMENT_METHOD",
    "IS_CONTACTLESS"::BOOLEAN,
    CURRENT_TIMESTAMP,
    "SOURCE_SYSTEM",
    "SOURCE_ENTITY"
FROM (
    SELECT DISTINCT 
        "PAYMENT_METHOD",
        "IS_CONTACTLESS",
        'SA_OFFLINE_SALES' AS "SOURCE_SYSTEM",
        'SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS' AS "SOURCE_ENTITY"      
    FROM SA_OFFLINE_SALES.SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS 
    UNION 
     SELECT DISTINCT 
        "PAYMENT_METHOD",
        "IS_CONTACTLESS",
        'SA_ONLINE_SALES' AS "SOURCE_SYSTEM",
        'SRC_ONLINE_COFFEE_SHOP_TRANSACTIONS' AS "SOURCE_ENTITY"   
    FROM SA_ONLINE_SALES.SRC_ONLINE_COFFEE_SHOP_TRANSACTIONS 
) PM
ON CONFLICT("PAYMENT_METHOD_SRC_ID","SOURCE_SYSTEM","SOURCE_ENTITY") DO NOTHING;
GET DIAGNOSTICS ROWS_INSERTED = ROW_COUNT;
      CALL BL_CL.LOG_ETL('LOAD_CE_PAYMENT_METHODS', ROWS_INSERTED, 'SUCCESS');
EXCEPTION  WHEN OTHERS THEN
       CALL BL_CL.LOG_ETL('LOAD_CE_PAYMENT_METHODS', 0, 'ERROR: ' || SQLERRM);
END;
$$;

--CE_LOAD_PAYMENT_PROVIDERS 
CREATE OR REPLACE PROCEDURE BL_CL.LOAD_CE_PAYMENT_PROVIDERS()
LANGUAGE PLPGSQL
AS $$
DECLARE ROWS_INSERTED INTEGER:=0;
BEGIN
	INSERT INTO BL_3NF.CE_PAYMENT_PROVIDERS (
    "PAYMENT_PROVIDER_ID",
    "PAYMENT_PROVIDER_SRC_ID",
    "PAYMENT_PROVIDER_DESC",
    "TA_INSERT_DT",
    "SOURCE_SYSTEM",
    "SOURCE_ENTITY")
SELECT 
   NEXTVAL('BL_3NF.CE_PAYMENT_PROVIDERS_SEQ'),
   COALESCE(PP."PAYMENT_PROVIDER",'N.A.') AS "PAYMENT_PROVIDER",
   COALESCE(PP."PAYMENT_PROVIDER",'N.A.') AS "PAYMENT_PROVIDER",
    CURRENT_TIMESTAMP,
    "SOURCE_SYSTEM",
    "SOURCE_ENTITY"

FROM (
    SELECT DISTINCT 
    "PAYMENT_PROVIDER",
    'SA_OFFLINE_SALES' AS "SOURCE_SYSTEM",
    'SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS' AS "SOURCE_ENTITY"
    FROM SA_OFFLINE_SALES.SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS
    UNION ALL 
    SELECT DISTINCT 
    "PAYMENT_PROVIDER",
    'SA_ONLINE_SALES' AS "SOURCE_SYSTEM",
    'SRC_ONLINE_COFFEE_SHOP_TRANSACTIONS' AS "SOURCE_ENTITY"
    FROM SA_ONLINE_SALES.SRC_ONLINE_COFFEE_SHOP_TRANSACTIONS
) PP
ON CONFLICT ("PAYMENT_PROVIDER_SRC_ID","SOURCE_SYSTEM","SOURCE_ENTITY") DO NOTHING;
GET DIAGNOSTICS ROWS_INSERTED = ROW_COUNT;
      CALL BL_CL.LOG_ETL('LOAD_CE_PAYMENT_PROVIDERS', ROWS_INSERTED, 'SUCCESS');
EXCEPTION  WHEN OTHERS THEN
       CALL BL_CL.LOG_ETL('LOAD_CE_PAYMENT_PROVIDERS', 0, 'ERROR: ' || SQLERRM);
END;
$$;


--LOAD_CE_PAYMENTS
CREATE OR REPLACE PROCEDURE BL_CL.LOAD_CE_PAYMENTS()
LANGUAGE PLPGSQL
AS $$
DECLARE ROWS_INSERTED INTEGER:=0;
BEGIN
	INSERT INTO BL_3NF.CE_PAYMENTS (
    "PAYMENT_ID",
    "PAYMENT_SRC_ID",
    "PAYMENT_PROVIDER_ID",
    "PAYMENT_METHOD_ID",
    "TRANSACTION_FEE",
    "TA_INSERT_DT",
    "SOURCE_SYSTEM",
    "SOURCE_ENTITY") 
SELECT 
    NEXTVAL('BL_3NF.CE_PAYMENTS_SEQ'),
    P."PAYMENT_ID"::BIGINT,
    COALESCE(PP."PAYMENT_PROVIDER_ID", -1),
    COALESCE(PM."PAYMENT_METHOD_ID", -1),
    P."TRANSACTION_FEE":: DECIMAL(8,2),
    CURRENT_TIMESTAMP,
    P."SOURCE_SYSTEM",
    P."SOURCE_ENTITY"
FROM (SELECT DISTINCT
			"PAYMENT_ID" AS "PAYMENT_ID",
			"TRANSACTION_FEE" AS "TRANSACTION_FEE",
			"PAYMENT_PROVIDER" AS "PAYMENT_PROVIDER",
			"PAYMENT_METHOD" AS "PAYMENT_METHOD",
			'SA_OFFLINE_SALES' AS "SOURCE_SYSTEM",
  			'SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS' AS "SOURCE_ENTITY"
  	FROM SA_OFFLINE_SALES.SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS 
  	UNION ALL 
	SELECT DISTINCT 
			"PAYMENT_ID" AS "PAYMENT_ID",
			"TRANSACTION_FEE_RATE" AS "TRANSACTION_FEE",
			"PAYMENT_PROVIDER" AS "PAYMENT_PROVIDER",
			"PAYMENT_METHOD" AS "PAYMENT_METHOD",
			'SA_ONLINE_SALES' AS "SOURCE_SYSTEM",
  			'SRC_ONLINE_COFFEE_SHOP_TRANSACTIONS' AS "SOURCE_ENTITY"
  	FROM SA_ONLINE_SALES.SRC_ONLINE_COFFEE_SHOP_TRANSACTIONS ) P
LEFT JOIN BL_3NF.CE_PAYMENT_PROVIDERS PP 
    ON LOWER(PP."PAYMENT_PROVIDER_SRC_ID") = LOWER(P."PAYMENT_PROVIDER")
    AND PP."SOURCE_SYSTEM"=P."SOURCE_SYSTEM" AND PP."SOURCE_ENTITY"=P."SOURCE_ENTITY" 
    LEFT JOIN BL_3NF.CE_PAYMENT_METHODS PM 
    ON LOWER(PM."PAYMENT_METHOD_SRC_ID") = LOWER(P."PAYMENT_METHOD")
     AND PM."SOURCE_SYSTEM"=P."SOURCE_SYSTEM" AND PM."SOURCE_ENTITY"=P."SOURCE_ENTITY"
ON CONFLICT("PAYMENT_SRC_ID","SOURCE_SYSTEM","SOURCE_ENTITY") DO NOTHING;
GET DIAGNOSTICS ROWS_INSERTED = ROW_COUNT;
      CALL BL_CL.LOG_ETL('LOAD_CE_PAYMENTS', ROWS_INSERTED, 'SUCCESS');
EXCEPTION  WHEN OTHERS THEN
       CALL BL_CL.LOG_ETL('LOAD_CE_PAYMENTS', 0, 'ERROR: ' || SQLERRM);
END;
$$;


--CE_LOAD_STAFF
CREATE OR REPLACE PROCEDURE BL_CL.LOAD_CE_STAFF()
LANGUAGE PLPGSQL
AS $$
DECLARE ROWS_INSERTED INTEGER:=0;
BEGIN
	WITH ranked_staff AS ( SELECT distinct "STAFF_ID","STAFF_FIRST_NAME","STAFF_LAST_NAME","JOB_START_DT","EMPLOYMENT_STATUS","HOURLY_WAGE", ROW_NUMBER() OVER (PARTITION BY "STAFF_ID" ORDER BY "EVENT_DT" DESC) AS rn
    FROM SA_OFFLINE_SALES.SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS )
	INSERT INTO BL_3NF.CE_STAFF (
    "STAFF_ID",
    "STAFF_SRC_ID",
    "STAFF_FIRST_NAME",
    "STAFF_LAST_NAME",
    "JOB_START_DT",
    "EMPLOYMENT_STATUS",
    "HOURLY_WAGE",
    "TA_INSERT_DT",
    "SOURCE_SYSTEM",
    "SOURCE_ENTITY")
SELECT 
   nextval('BL_3NF.CE_STAFF_SEQ'),
    s."STAFF_ID",
    s."STAFF_FIRST_NAME",
    s."STAFF_LAST_NAME",
    TO_DATE(s."JOB_START_DT", 'MM/DD/YYYY'),
    s."EMPLOYMENT_STATUS",
    s."HOURLY_WAGE" :: DECIMAL(10,2),
    CURRENT_TIMESTAMP,
    'SA_OFFLINE_SALES',
    'SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS'
  FROM ranked_staff s
  WHERE rn = 1
ON CONFLICT ("STAFF_SRC_ID","SOURCE_SYSTEM","SOURCE_ENTITY") DO
update set 
"STAFF_FIRST_NAME"=excluded."STAFF_FIRST_NAME",
"STAFF_LAST_NAME"=excluded."STAFF_LAST_NAME",
"JOB_START_DT"=excluded."JOB_START_DT",
"EMPLOYMENT_STATUS"=excluded."EMPLOYMENT_STATUS",
"HOURLY_WAGE"=excluded."HOURLY_WAGE"

where( 
bl_3nf.ce_staff."STAFF_FIRST_NAME" is distinct from excluded."STAFF_FIRST_NAME" or
bl_3nf.ce_staff."STAFF_LAST_NAME" is distinct from excluded."STAFF_LAST_NAME" or
bl_3nf.ce_staff."JOB_START_DT" is distinct from excluded."JOB_START_DT" or
bl_3nf.ce_staff."EMPLOYMENT_STATUS" is distinct from excluded."EMPLOYMENT_STATUS" or
bl_3nf.ce_staff."HOURLY_WAGE" is distinct from excluded."HOURLY_WAGE");

GET DIAGNOSTICS ROWS_INSERTED = ROW_COUNT;
      CALL BL_CL.LOG_ETL('LOAD_CE_STAFF', ROWS_INSERTED, 'SUCCESS');
EXCEPTION  WHEN OTHERS THEN
       CALL BL_CL.LOG_ETL('LOAD_CE_STAFF', 0, 'ERROR: ' || SQLERRM);
END;
$$;


--LOAD_CE_STORES
CREATE OR REPLACE PROCEDURE BL_CL.LOAD_CE_STORES()
LANGUAGE PLPGSQL
AS $$
DECLARE ROWS_INSERTED INTEGER:=0;
BEGIN
	with all_stores as( SELECT DISTINCT 
       "STORE_ID",
       "STORE_ADDRESS",
       "STORE_TYPE",
       "STORE_DESC",
	     "WEBSITE",
       "STORE_CITY",
       "STORE_COUNTRY",
		   "EVENT_DT",
       'SA_ONLINE_SALES' AS "SOURCE_SYSTEM",
       'SRC_ONLINE_COFFEE_SHOP_TRANSACTIONS' AS "SOURCE_ENTITY"
    FROM SA_ONLINE_SALES.SRC_ONLINE_COFFEE_SHOP_TRANSACTIONS
    UNION ALL
    SELECT DISTINCT 
       "STORE_ID",
       "STORE_ADDRESS",
       "STORE_TYPE",
       "STORE_DESC",
	     'n.a.' as "WEBSITE",
       "STORE_CITY",
       "STORE_COUNTRY",
		   "EVENT_DT",
       'SA_OFFLINE_SALES' AS "SOURCE_SYSTEM",
       'SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS' AS "SOURCE_ENTITY"
    FROM SA_OFFLINE_SALES.SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS),
latest_stores as (select *, row_number() over(partition by "STORE_ID","SOURCE_SYSTEM","SOURCE_ENTITY" ORDER BY "EVENT_DT" DESC) AS rn from all_stores)
	INSERT INTO BL_3NF.CE_STORES (
    "STORE_ID",
    "STORE_SRC_ID",
    "CITY_ID",
	  "WEBSITE",
    "STORE_DESC",
    "STORE_ADDRESS",
    "STORE_TYPE",
    "TA_INSERT_DT",
    "SOURCE_SYSTEM",
    "SOURCE_ENTITY")
SELECT 
    NEXTVAL('BL_3NF.CE_STORES_SEQ'),
    S."STORE_ID",
    COALESCE(CI."CITY_ID", -1),
	  S."WEBSITE",
    S."STORE_DESC",
    S."STORE_ADDRESS",
    S."STORE_TYPE",
    CURRENT_TIMESTAMP,
    S."SOURCE_SYSTEM",
    S."SOURCE_ENTITY"
FROM latest_stores S
LEFT JOIN BL_3NF.CE_CITIES CI 
    ON CI."CITY_SRC_ID" = S."STORE_CITY" || ' | ' || S."STORE_COUNTRY"
    AND CI."SOURCE_ENTITY"=S."SOURCE_ENTITY" AND CI."SOURCE_SYSTEM" = S."SOURCE_SYSTEM"
where S.rn =1
ON CONFLICT("STORE_SRC_ID","SOURCE_SYSTEM","SOURCE_ENTITY") DO 
update set  
"CITY_ID"=excluded."CITY_ID",
"WEBSITE"=excluded."WEBSITE",
"STORE_DESC"=excluded."STORE_DESC",
"STORE_ADDRESS"=excluded."STORE_ADDRESS",
"STORE_TYPE"=excluded."STORE_TYPE"

where 
BL_3NF.CE_STORES."CITY_ID" is distinct from excluded."CITY_ID" or
BL_3NF.CE_STORES."WEBSITE" is distinct from excluded."WEBSITE" or
BL_3NF.CE_STORES."STORE_DESC" is distinct from excluded."STORE_DESC" or
BL_3NF.CE_STORES."STORE_ADDRESS" is distinct from excluded."STORE_ADDRESS" or
BL_3NF.CE_STORES."STORE_TYPE" is distinct from excluded."STORE_TYPE";
GET DIAGNOSTICS ROWS_INSERTED = ROW_COUNT;
      CALL BL_CL.LOG_ETL('LOAD_CE_STORES', ROWS_INSERTED, 'SUCCESS');
EXCEPTION  WHEN OTHERS THEN
       CALL BL_CL.LOG_ETL('LOAD_CE_STORES', 0, 'ERROR: ' || SQLERRM);
END;
$$;


--LOAD_CE_STAFF_JOBS
CREATE OR REPLACE PROCEDURE BL_CL.LOAD_CE_STAFF_JOBS()
LANGUAGE PLPGSQL
AS $$
DECLARE ROWS_INSERTED INTEGER :=0;
BEGIN
	INSERT INTO BL_3NF.CE_STAFF_JOBS (
    "STAFF_JOB_ID",
    "STAFF_JOB_SRC_ID",
    "STAFF_ID",
    "JOB_ID",
    "TA_INSERT_DT",
    "SOURCE_SYSTEM",
    "SOURCE_ENTITY"
)
SELECT 
    NEXTVAL('BL_3NF.CE_STAFF_JOBS_SEQ'),
    SJ."STAFF_ID" || ' | ' || SJ."JOB_DESC",
    COALESCE(S."STAFF_ID", -1),
    COALESCE(J."JOB_ID", -1),
    CURRENT_TIMESTAMP,
    'SA_OFFLINE_SALES',
    'SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS'
FROM (
    SELECT DISTINCT 
      "STAFF_ID",
      "STAFF_JOB_DESC" AS "JOB_DESC"
    FROM SA_OFFLINE_SALES.SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS
) SJ
LEFT JOIN BL_3NF.CE_STAFF S ON S."STAFF_SRC_ID" = SJ."STAFF_ID"
LEFT JOIN BL_3NF.CE_JOBS J ON J."JOB_SRC_ID" = SJ."JOB_DESC"
ON CONFLICT ("STAFF_JOB_SRC_ID","SOURCE_SYSTEM","SOURCE_ENTITY") DO nothing;
GET DIAGNOSTICS ROWS_INSERTED = ROW_COUNT;
      CALL BL_CL.LOG_ETL('LOAD_CE_STAFF_JOBS', ROWS_INSERTED, 'SUCCESS');
EXCEPTION  WHEN OTHERS THEN
       CALL BL_CL.LOG_ETL('LOAD_CE_STAFF_JOBS', 0, 'ERROR: ' || SQLERRM);
END;
$$;

--LOAD_CE_STAFF_STORES
CREATE OR REPLACE PROCEDURE BL_CL.LOAD_CE_STAFF_STORES()
LANGUAGE PLPGSQL
AS $$
DECLARE ROWS_INSERTED INTEGER:=0;
BEGIN
	INSERT INTO BL_3NF.CE_STAFF_STORES (
    "STAFF_STORE_ID",
    "STAFF_STORE_SRC_ID",
    "STAFF_ID",
    "STORE_ID",
    "TA_INSERT_DT",
    "SOURCE_SYSTEM",
    "SOURCE_ENTITY"
)
SELECT 
    NEXTVAL('BL_3NF.CE_STAFF_STORES_SEQ'),
    SS."STAFF_ID"|| ' | ' || SS."STORE_ID",
    COALESCE(S."STAFF_ID", -1),
    COALESCE(ST."STORE_ID", -1),
    CURRENT_TIMESTAMP,
    'SA_OFFLINE_SALES',
    'SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS'
FROM (
    SELECT DISTINCT 
        "STAFF_ID",
        "STORE_ID"
    FROM SA_OFFLINE_SALES.SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS
) SS
LEFT JOIN BL_3NF.CE_STAFF S ON S."STAFF_SRC_ID" = SS."STAFF_ID"
LEFT JOIN BL_3NF.CE_STORES ST ON ST."STORE_SRC_ID" = SS."STORE_ID"
ON CONFLICT ("STAFF_STORE_SRC_ID","SOURCE_SYSTEM","SOURCE_ENTITY") DO nothing;
GET DIAGNOSTICS ROWS_INSERTED = ROW_COUNT;
      CALL BL_CL.LOG_ETL('LOAD_CE_STAFF_STORES', ROWS_INSERTED, 'SUCCESS');
EXCEPTION  WHEN OTHERS THEN
       CALL BL_CL.LOG_ETL('LOAD_CE_STAFF_STORES', 0, 'ERROR: ' || SQLERRM);
END;
$$;



--LOAD_CE_CUSTOMERS_SCD
CREATE OR REPLACE PROCEDURE BL_CL.LOAD_CE_CUSTOMERS_SCD()
LANGUAGE PLPGSQL
AS $$
DECLARE
  ROWS_UPDATED INTEGER := 0;
  ROWS_INSERTED INTEGER := 0;
BEGIN
  CREATE TEMP TABLE IF NOT EXISTS TEMP_CE_CUSTOMERS_SCD (
    "CUSTOMER_SRC_ID" BIGINT,
    "CUSTOMER_FIRST_NAME" VARCHAR(255),
    "CUSTOMER_LAST_NAME" VARCHAR(255),
    "COUNTRY_ID" BIGINT,
    "LOYALTY_MEMBER" BOOLEAN,
    "LOYALTY_DISCOUNT" DECIMAL(8,2),
    "GENDER" VARCHAR(255),
    "BIRTH_YEAR" BIGINT,
    "SIGNUP_DT" DATE,
    "SOURCE_SYSTEM" VARCHAR(255),
    "SOURCE_ENTITY" VARCHAR(255)
  );
   truncate temp_ce_customers_scd ;


	with all_customers as (
						select distinct
						ons."CUSTOMER_ID" AS "CUSTOMER_SRC_ID",
					    ons."CUSTOMER_FIRST_NAME" AS "CUSTOMER_FIRST_NAME",
					    ons."CUSTOMER_LAST_NAME" AS "CUSTOMER_LAST_NAME",
					    ons."CUSTOMER_COUNTRY" AS "CUSTOMER_COUNTRY",
					    ons."LOYALTY_MEMBER" AS "LOYALTY_MEMBER",
					    ons."LOYALTY_DISCOUNT" AS "LOYALTY_DISCOUNT",
					    ons."GENDER" AS "GENDER",
					    ons."BIRTH_YEAR" AS "BIRTH_YEAR",
					    ons."SIGNUP_DT"  AS "SIGNUP_DT",
					    ons."EVENT_DT" AS "EVENT_DT",
					    'SA_ONLINE_SALES' AS "SOURCE_SYSTEM",
					    'SRC_ONLINE_COFFEE_SHOP_TRANSACTIONS' AS "SOURCE_ENTITY"
						FROM SA_ONLINE_SALES.SRC_ONLINE_COFFEE_SHOP_TRANSACTIONS  ons
						union all
						select distinct 
						ofs."CUSTOMER_ID" AS "CUSTOMER_SRC_ID",
					    ofs."CUSTOMER_FIRST_NAME" AS "CUSTOMER_FIRST_NAME",
					    ofs."CUSTOMER_LAST_NAME" AS "CUSTOMER_LAST_NAME",
					    ofs."CUSTOMER_COUNTRY" AS "CUSTOMER_COUNTRY",
					    ofs."LOYALTY_MEMBER" AS "LOYALTY_MEMBER",
					    ofs."LOYALTY_DISCOUNT" AS "LOYALTY_DISCOUNT",
					    ons."GENDER" AS "GENDER",
					    ons."BIRTH_YEAR" AS "BIRTH_YEAR",
					    NULL AS "SIGNUP_DT",
					    ofs."EVENT_DT" AS "EVENT_DT",
					    'SA_OFFLINE_SALES' AS "SOURCE_SYSTEM",
					    'SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS' AS "SOURCE_ENTITY"
						FROM SA_OFFLINE_SALES.SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS ofs
						left join (select distinct "CUSTOMER_ID","GENDER","BIRTH_YEAR"
								   from SA_ONLINE_SALES.SRC_ONLINE_COFFEE_SHOP_TRANSACTIONS) ons
						on ofs."CUSTOMER_ID"=ons."CUSTOMER_ID"),
mapping_joined as (select  distinct
						  M."CUSTOMER_ID" AS "CUSTOMER_ID",
					      M."CUSTOMER_FIRST_NAME" as "CUSTOMER_FIRST_NAME",
					      M."CUSTOMER_LAST_NAME" as "CUSTOMER_LAST_NAME",
					      S."CUSTOMER_COUNTRY" as "CUSTOMER_COUNTRY",
					      S."LOYALTY_MEMBER" as "LOYALTY_MEMBER",
					      S."LOYALTY_DISCOUNT" as "LOYALTY_DISCOUNT",
					      S."GENDER" as "GENDER",
					      S."BIRTH_YEAR" as "BIRTH_YEAR",
					      S."SIGNUP_DT" as "SIGNUP_DT",
						  S."EVENT_DT" as "EVENT_DT",
					      S."SOURCE_SYSTEM" as "SOURCE_SYSTEM",
					      S."SOURCE_ENTITY" as "SOURCE_ENTITY"
					from all_customers S
					 LEFT JOIN BL_CL.T_MAP_CUSTOMERS M
				      ON S."CUSTOMER_SRC_ID" = M."CUSTOMER_SRC_ID"
				     AND S."SOURCE_SYSTEM" = M."SOURCE_SYSTEM"
				     AND S."SOURCE_ENTITY" = M."SOURCE_ENTITY"),		
	latest_customers AS (select *, 
						row_number() over(partition by "CUSTOMER_ID" ORDER BY "EVENT_DT" DESC) as rn
  						from mapping_joined)

  INSERT INTO TEMP_CE_CUSTOMERS_SCD (
    "CUSTOMER_SRC_ID", "CUSTOMER_FIRST_NAME", "CUSTOMER_LAST_NAME", "COUNTRY_ID",
    "LOYALTY_MEMBER", "LOYALTY_DISCOUNT", "GENDER", "BIRTH_YEAR", "SIGNUP_DT",
    "SOURCE_SYSTEM", "SOURCE_ENTITY")
  SELECT distinct 
    C."CUSTOMER_ID",
    C."CUSTOMER_FIRST_NAME",
    C."CUSTOMER_LAST_NAME",
    COALESCE(CNT."COUNTRY_ID", -1),
    C."LOYALTY_MEMBER"::BOOLEAN,
    C."LOYALTY_DISCOUNT"::DECIMAL(8,2),
    coalesce(C."GENDER",'n.a.'),
    coalesce(C."BIRTH_YEAR"::BIGINT,-1),
    COALESCE(TO_DATE(C."SIGNUP_DT", 'MM/DD/YYYY'), DATE '1900-01-01'),
    'BL_CL',
    'T_MAP_CUSTOMERS'
  FROM (
    SELECT distinct
      S."CUSTOMER_ID",
      S."CUSTOMER_FIRST_NAME",
      S."CUSTOMER_LAST_NAME",
      S."CUSTOMER_COUNTRY",
      S."LOYALTY_MEMBER",
      S."LOYALTY_DISCOUNT",
      S."GENDER",
      S."BIRTH_YEAR",
      S."SIGNUP_DT",
      S."SOURCE_SYSTEM",
      S."SOURCE_ENTITY"
    FROM latest_customers S
    where rn =1
  ) C
  LEFT JOIN BL_3NF.CE_COUNTRIES CNT
    ON CNT."COUNTRY_DESC" = C."CUSTOMER_COUNTRY"
   AND CNT."SOURCE_SYSTEM" = C."SOURCE_SYSTEM"
   AND CNT."SOURCE_ENTITY" = C."SOURCE_ENTITY";

 WITH changed_customers AS (
    SELECT tgt.*
    FROM BL_3NF.CE_CUSTOMERS_SCD tgt
    JOIN TEMP_CE_CUSTOMERS_SCD src
      ON tgt."CUSTOMER_SRC_ID" = src."CUSTOMER_SRC_ID"
     AND tgt."SOURCE_SYSTEM" = src."SOURCE_SYSTEM"
     AND tgt."SOURCE_ENTITY" = src."SOURCE_ENTITY"
     AND  tgt."IS_ACTIVE" = TRUE
      AND tgt."END_DT" = '9999-12-31'::TIMESTAMP
      WHERE (
        tgt."CUSTOMER_SRC_ID" IS DISTINCT FROM src."CUSTOMER_SRC_ID" OR
        tgt."CUSTOMER_FIRST_NAME" IS DISTINCT FROM src."CUSTOMER_FIRST_NAME"
        OR tgt."CUSTOMER_LAST_NAME" IS DISTINCT FROM src."CUSTOMER_LAST_NAME"
        OR tgt."COUNTRY_ID" IS DISTINCT FROM src."COUNTRY_ID"
        OR tgt."LOYALTY_MEMBER" IS DISTINCT FROM src."LOYALTY_MEMBER"
        OR tgt."LOYALTY_DISCOUNT" IS DISTINCT FROM src."LOYALTY_DISCOUNT"
        OR tgt."GENDER" IS DISTINCT FROM src."GENDER"
        OR tgt."BIRTH_YEAR" IS DISTINCT FROM src."BIRTH_YEAR"
        OR tgt."SIGNUP_DT" IS DISTINCT FROM src."SIGNUP_DT"
      )
  )
  UPDATE BL_3NF.CE_CUSTOMERS_SCD tgt
  SET "IS_ACTIVE" = FALSE,
      "END_DT" = CURRENT_TIMESTAMP
  FROM changed_customers cc
  WHERE tgt."CUSTOMER_SRC_ID" = cc."CUSTOMER_SRC_ID"
    AND tgt."IS_ACTIVE" = TRUE
    AND tgt."END_DT" = '9999-12-31'::TIMESTAMP;

  GET DIAGNOSTICS ROWS_UPDATED = ROW_COUNT;

  WITH to_insert AS (
    SELECT distinct src.*
    FROM TEMP_CE_CUSTOMERS_SCD src
    LEFT JOIN BL_3NF.CE_CUSTOMERS_SCD tgt
      ON tgt."CUSTOMER_SRC_ID" = src."CUSTOMER_SRC_ID"
     AND tgt."SOURCE_SYSTEM" = src."SOURCE_SYSTEM"
     AND tgt."SOURCE_ENTITY" = src."SOURCE_ENTITY"
     AND tgt."END_DT" = '9999-12-31'::TIMESTAMP
     AND tgt."CUSTOMER_FIRST_NAME" = src."CUSTOMER_FIRST_NAME"
     AND tgt."CUSTOMER_LAST_NAME" = src."CUSTOMER_LAST_NAME"
     AND tgt."COUNTRY_ID" = src."COUNTRY_ID"
     AND tgt."LOYALTY_MEMBER" = src."LOYALTY_MEMBER"
     AND tgt."LOYALTY_DISCOUNT" = src."LOYALTY_DISCOUNT"
     AND tgt."GENDER" = src."GENDER"
     AND tgt."BIRTH_YEAR" = src."BIRTH_YEAR"
     AND tgt."SIGNUP_DT" = src."SIGNUP_DT"
    WHERE tgt."CUSTOMER_ID" IS NULL --No active row in the target matches this exact source row  so we should insert it
  )
  INSERT INTO BL_3NF.CE_CUSTOMERS_SCD (
    "CUSTOMER_ID",
    "CUSTOMER_SRC_ID",
    "CUSTOMER_FIRST_NAME",
    "CUSTOMER_LAST_NAME",
    "COUNTRY_ID",
    "LOYALTY_MEMBER",
    "LOYALTY_DISCOUNT",
    "GENDER",
    "BIRTH_YEAR",
    "SIGNUP_DT",
    "START_DT",
    "END_DT",
    "IS_ACTIVE",
    "TA_INSERT_DT",
    "SOURCE_SYSTEM",
    "SOURCE_ENTITY"
  )
  SELECT
    NEXTVAL('BL_3NF.CE_CUSTOMERS_SEQ'),
    i."CUSTOMER_SRC_ID",
    i."CUSTOMER_FIRST_NAME",
    i."CUSTOMER_LAST_NAME",
    i."COUNTRY_ID",
    i."LOYALTY_MEMBER",
    i."LOYALTY_DISCOUNT",
    i."GENDER",
    i."BIRTH_YEAR",
    i."SIGNUP_DT",
    CURRENT_TIMESTAMP,
    '9999-12-31'::TIMESTAMP,
    TRUE,
    CURRENT_TIMESTAMP,
    'BL_CL',
    'T_MAP_CUSTOMERS'
  FROM to_insert i;

  GET DIAGNOSTICS ROWS_INSERTED= ROW_COUNT;
  call  BL_CL.LOG_ETL(  'LOAD_CE_CUSTOMERS_SCD', ROWS_UPDATED + ROWS_INSERTED,   'SUCCESS' );

EXCEPTION WHEN OTHERS THEN
  call  BL_CL.LOG_ETL('LOAD_CE_CUSTOMERS_SCD', 0, 'ERROR: ' || SQLERRM);
  RAISE;
END;
$$;


--LOAD_CE_SALES
CREATE OR REPLACE PROCEDURE BL_CL.LOAD_CE_SALES()
LANGUAGE plpgsql
AS $$
DECLARE 
v_last_event_dt_online bigint;
v_last_event_dt_offline bigint;
v_last_transaction_id_online varchar(200);
v_last_transaction_id_offline varchar(200);
v_rows_inserted_1 INT := 0;
v_rows_inserted_2 INT := 0;
BEGIN
	SELECT COALESCE(last_event_dt,-1), coalesce(last_transaction_id,'n.a.')
	INTO v_last_event_dt_online,v_last_transaction_id_online
	FROM bl_cl.load_tracker
	where lower(source_type)='online';
	
	SELECT COALESCE(last_event_dt,-1), coalesce(last_transaction_id,'n.a.')
	INTO v_last_event_dt_offline,v_last_transaction_id_offline
	FROM bl_cl.load_tracker
	where lower(source_type)='offline';
-- Online sales
INSERT INTO BL_3NF.CE_SALES (
"SALE_ID",
"SALE_SRC_ID",
"CUSTOMER_ID",
"STAFF_ID",
"STORE_ID",
"PAYMENT_ID",
"MANAGER_ID",
"PRODUCT_ID",
"EVENT_DT",
"QUANTITY",
"LINE_ITEM_AMOUNT",
"COST",
"PROFIT",
"PROFIT_MARGIN",
"DELIVERY_FEE",
"TA_INSERT_DT",
"SOURCE_SYSTEM",
"SOURCE_ENTITY"
)
SELECT 
nextval('BL_3NF.CE_SALES_SEQ'),
s."SALES_ID",
COALESCE(c."CUSTOMER_ID", -1),
-1, -- No staff for online sales
COALESCE(st."STORE_ID", -1),
COALESCE(p."PAYMENT_ID", -1),
-1, -- No manager for online sales
COALESCE(pr."PRODUCT_ID", -1),
s."EVENT_DT"::BIGINT,
s."QUANTITY"::INTEGER,
s."LINE_ITEM_AMOUNT"::DECIMAL(8,2),
s."COST"::DECIMAL(8,2),
s."PROFIT"::DECIMAL(8,2),
s."PROFIT_MARGIN"::DECIMAL(8,2),
s."DELIVERY_FEE"::DECIMAL(8,2),
CURRENT_TIMESTAMP,
'SA_ONLINE_SALES',
'SRC_ONLINE_COFFEE_SHOP_TRANSACTIONS'
FROM sa_online_sales.src_online_coffee_shop_transactions s
LEFT JOIN BL_CL.T_MAP_CUSTOMERS mp
ON mp."CUSTOMER_SRC_ID" = s."CUSTOMER_ID" 
AND mp."SOURCE_SYSTEM" = 'SA_ONLINE_SALES' 
AND mp."SOURCE_ENTITY" = 'SRC_ONLINE_COFFEE_SHOP_TRANSACTIONS'
LEFT JOIN BL_3NF.CE_CUSTOMERS_SCD c 
ON c."CUSTOMER_SRC_ID"::BIGINT = mp."CUSTOMER_ID"::BIGINT
AND c."IS_ACTIVE"=TRUE
LEFT JOIN BL_3NF.CE_STORES st 
ON st."STORE_SRC_ID" = s."STORE_ID" 
AND st."SOURCE_SYSTEM" = 'SA_ONLINE_SALES' 
AND st."SOURCE_ENTITY" = 'SRC_ONLINE_COFFEE_SHOP_TRANSACTIONS'
LEFT JOIN BL_3NF.CE_PAYMENTS p 
ON p."PAYMENT_SRC_ID"::BIGINT = s."PAYMENT_ID"::BIGINT 
AND p."SOURCE_SYSTEM" = 'SA_ONLINE_SALES' 
AND p."SOURCE_ENTITY" = 'SRC_ONLINE_COFFEE_SHOP_TRANSACTIONS'
LEFT JOIN BL_cl.t_map_products mpp
ON mpp."PRODUCT_SRC_ID" = s."PRODUCT_ID"
AND mpp."SOURCE_SYSTEM" = 'SA_ONLINE_SALES' 
AND mpp."SOURCE_ENTITY" = 'SRC_ONLINE_COFFEE_SHOP_TRANSACTIONS'
LEFT JOIN BL_3NF.CE_PRODUCTS pr
ON pr."PRODUCT_SRC_ID" = mpp."PRODUCT_ID"
where S."EVENT_DT"::bigint >v_last_event_dt_online or 
	  (S."EVENT_DT"::bigint =v_last_event_dt_online and S."SALES_ID" >v_last_transaction_id_online) 
--if i only write >= it might load the same data twice thats why its better to check for sales_id also
On conflict("SALE_SRC_ID","SOURCE_ENTITY","SOURCE_SYSTEM") DO NOTHING;
GET DIAGNOSTICS v_rows_inserted_1 = ROW_COUNT;
IF v_rows_inserted_1 > 0 THEN
INSERT INTO BL_CL.load_tracker(source_type,last_event_dt,last_transaction_id,last_updated)
SELECT 'ONLINE',
		coalesce(max(S."EVENT_DT")::bigint,-1),
		coalesce(max(S."SALES_ID"),'n.a.'),
		CURRENT_TIMESTAMP
FROM sa_online_sales.src_online_coffee_shop_transactions S
WHERE S."EVENT_DT"::bigint >v_last_event_dt_online or 
	  (S."EVENT_DT"::bigint =v_last_event_dt_online and S."SALES_ID" >v_last_transaction_id_online)
ON CONFLICT (source_type) do 
update set source_type=excluded.source_type,
		   last_event_dt=excluded.last_event_dt,
		   last_transaction_id=excluded.last_transaction_id,
		   last_updated=CURRENT_TIMESTAMP ;
end if;
-- Offline sales
INSERT INTO BL_3NF.CE_SALES (
"SALE_ID",
"SALE_SRC_ID",
"CUSTOMER_ID",
"STAFF_ID",
"STORE_ID",
"PAYMENT_ID",
"MANAGER_ID",
"PRODUCT_ID",
"EVENT_DT",
"QUANTITY",
"LINE_ITEM_AMOUNT",
"COST",
"PROFIT",
"PROFIT_MARGIN",
"DELIVERY_FEE",
"TA_INSERT_DT",
"SOURCE_SYSTEM",
"SOURCE_ENTITY"
)
SELECT 
nextval('BL_3NF.CE_SALES_SEQ'),
s."SALES_ID",
COALESCE(c."CUSTOMER_ID", -1),
COALESCE(stf."STAFF_ID", -1),
COALESCE(st."STORE_ID", -1),
COALESCE(p."PAYMENT_ID", -1),
COALESCE(mgr."STAFF_ID", -1),
COALESCE(pr."PRODUCT_ID", -1),
s."EVENT_DT"::BIGINT,
s."QUANTITY"::INTEGER,
s."LINE_ITEM_AMOUNT"::DECIMAL(8,2),
s."COST"::DECIMAL(8,2),
s."PROFIT"::DECIMAL(8,2),
s."PROFIT_MARGIN"::DECIMAL(8,2),
0, -- Delivery fee
CURRENT_TIMESTAMP,
'SA_OFFLINE_SALES',
'SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS'
FROM sa_offline_sales.src_offline_coffee_shop_transactions s
LEFT JOIN BL_CL.T_MAP_CUSTOMERS mp
ON mp."CUSTOMER_SRC_ID" = s."CUSTOMER_ID" 
AND mp."SOURCE_SYSTEM" = 'SA_OFFLINE_SALES' 
AND mp."SOURCE_ENTITY" = 'SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS'
LEFT JOIN BL_3NF.CE_CUSTOMERS_SCD c 
ON c."CUSTOMER_SRC_ID"::BIGINT = mp."CUSTOMER_ID" 
AND c."IS_ACTIVE"=TRUE
LEFT JOIN BL_3NF.CE_STAFF stf 
ON stf."STAFF_SRC_ID" = s."STAFF_ID"
LEFT JOIN BL_3NF.CE_STORES st 
ON st."STORE_SRC_ID" = s."STORE_ID" 
AND st."SOURCE_SYSTEM" = 'SA_OFFLINE_SALES' 
AND st."SOURCE_ENTITY" = 'SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS'
LEFT JOIN BL_3NF.CE_PAYMENTS p 
ON p."PAYMENT_SRC_ID"::BIGINT = s."PAYMENT_ID"::BIGINT 
AND p."SOURCE_SYSTEM" = 'SA_OFFLINE_SALES' 
AND p."SOURCE_ENTITY" = 'SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS'
LEFT JOIN BL_3NF.CE_STAFF mgr 
ON mgr."STAFF_SRC_ID" = s."MANAGER_ID" 
LEFT JOIN BL_cl.t_map_products mpp
ON mpp."PRODUCT_SRC_ID" = s."PRODUCT_ID"
AND mpp."SOURCE_SYSTEM" = 'SA_OFFLINE_SALES' 
AND mpp."SOURCE_ENTITY" = 'SRC_OFFLINE_COFFEE_SHOP_TRANSACTIONS'
LEFT JOIN BL_3NF.CE_PRODUCTS pr
ON pr."PRODUCT_SRC_ID" = mpp."PRODUCT_ID"
where (S."EVENT_DT"::bigint >v_last_event_dt_offline) or 
	  (S."EVENT_DT"::bigint =v_last_event_dt_offline and S."SALES_ID" >v_last_transaction_id_offline) 
On conflict("SALE_SRC_ID","SOURCE_ENTITY","SOURCE_SYSTEM") DO NOTHING;
GET DIAGNOSTICS v_rows_inserted_2 = ROW_COUNT;
IF v_rows_inserted_2 > 0 THEN
INSERT INTO BL_CL.load_tracker(source_type,last_event_dt,last_transaction_id,last_updated)
SELECT 'OFFLINE',
		coalesce(max(S."EVENT_DT")::bigint,-1),
		coalesce(max(S."SALES_ID"),'n.a.'),
		CURRENT_TIMESTAMP
FROM sa_offline_sales.src_offline_coffee_shop_transactions S
WHERE S."EVENT_DT"::bigint >v_last_event_dt_offline or 
	  (S."EVENT_DT"::bigint =v_last_event_dt_offline and S."SALES_ID" >v_last_transaction_id_offline)
ON CONFLICT (source_type) do 
update set source_type=excluded.source_type,
		   last_event_dt=excluded.last_event_dt,
		   last_transaction_id=excluded.last_transaction_id,
		   last_updated=CURRENT_TIMESTAMP ;
end if;

CALL BL_CL.LOG_ETL('LOAD_CE_SALES', v_rows_inserted_1 + v_rows_inserted_2, 'SUCCESS');
EXCEPTION WHEN OTHERS THEN
CALL BL_CL.LOG_ETL('LOAD_CE_SALES', 0, 'ERROR: ' || SQLERRM);
END;
$$;

--LOAD_DIM_PRODUCTS
CREATE OR REPLACE PROCEDURE bl_cl.load_dim_products()
LANGUAGE plpgsql
AS $$
DECLARE
    rows_inserted INTEGER := 0;
    v_rows INTEGER;
    rec RECORD;
BEGIN
    FOR rec IN  SELECT 
            cp."PRODUCT_ID",
            cp."PRODUCT_DESC",
            cp."PRODUCT_TYPE_ID",
            pt."PRODUCT_TYPE_DESC",
            pc."PRODUCT_CATEGORY_ID",
            pc."PRODUCT_CATEGORY_DESC",
            pg."PRODUCT_GROUP_ID",
            pg."PRODUCT_GROUP_DESC",
            cp."PROMO_FLAG",
            cp."PROMO_DISCOUNT",
            cp."BASE_PRICE",
            cp."IS_LIMITED_EDITION",
            current_timestamp as "TA_INSERT_DT",
            current_timestamp AS "TA_UPDATE_DT",
            'BL_3NF' AS "SOURCE_SYSTEM",
            'CE_PRODUCTS' AS "SOURCE_ENTITY"
        FROM bl_3nf.ce_products cp
        JOIN bl_3nf.ce_product_types pt ON cp."PRODUCT_TYPE_ID" = pt."PRODUCT_TYPE_ID"
        JOIN bl_3nf.ce_product_categories pc ON pt."PRODUCT_CATEGORY_ID" = pc."PRODUCT_CATEGORY_ID"
        JOIN bl_3nf.ce_product_groups pg ON pc."PRODUCT_GROUP_ID" = pg."PRODUCT_GROUP_ID"
    LOOP
        INSERT INTO bl_dm.dim_products (
            "PRODUCT_SURR_ID",
            "PRODUCT_SOURCE_ID",
            "PRODUCT_DESC",
            "PRODUCT_TYPE_ID",
            "PRODUCT_TYPE_DESC",
            "PRODUCT_CATEGORY_ID",
            "PRODUCT_CATEGORY_DESC",
            "PRODUCT_GROUP_ID",
            "PRODUCT_GROUP_DESC",
            "PROMO_FLAG",
            "PROMO_DISCOUNT",
            "BASE_PRICE",
            "IS_LIMITED_EDITION",
            "TA_INSERT_DT",
            "TA_UPDATE_DT",
            "SOURCE_SYSTEM",
            "SOURCE_ENTITY"
        )
        VALUES (
            nextval('bl_dm.dim_products_seq'),
            rec."PRODUCT_ID",
            rec."PRODUCT_DESC",
            rec."PRODUCT_TYPE_ID",
            rec."PRODUCT_TYPE_DESC",
            rec."PRODUCT_CATEGORY_ID",
            rec."PRODUCT_CATEGORY_DESC",
            rec."PRODUCT_GROUP_ID",
            rec."PRODUCT_GROUP_DESC",
            rec."PROMO_FLAG",
            rec."PROMO_DISCOUNT",
            rec."BASE_PRICE",
            rec."IS_LIMITED_EDITION",
            rec."TA_INSERT_DT",
            rec."TA_UPDATE_DT",
            rec."SOURCE_SYSTEM",
            rec."SOURCE_ENTITY"
        )
        ON CONFLICT ("PRODUCT_SOURCE_ID", "SOURCE_SYSTEM", "SOURCE_ENTITY")
        DO  update set
            "PRODUCT_DESC"=excluded."PRODUCT_DESC",
            "PRODUCT_TYPE_ID"=excluded."PRODUCT_TYPE_ID",
            "PRODUCT_TYPE_DESC"=excluded."PRODUCT_TYPE_DESC",
            "PRODUCT_CATEGORY_ID"=excluded."PRODUCT_CATEGORY_ID",
            "PRODUCT_CATEGORY_DESC"=excluded."PRODUCT_CATEGORY_DESC",
            "PRODUCT_GROUP_ID"=excluded."PRODUCT_GROUP_ID",
            "PRODUCT_GROUP_DESC"=excluded."PRODUCT_GROUP_DESC",
            "PROMO_FLAG"=excluded."PROMO_FLAG",
            "PROMO_DISCOUNT"=excluded."PROMO_DISCOUNT",
            "BASE_PRICE"=excluded."BASE_PRICE",
            "IS_LIMITED_EDITION"=excluded."IS_LIMITED_EDITION",
            "TA_UPDATE_DT"=current_timestamp 

where   bl_dm.dim_products."PRODUCT_DESC" is distinct  from excluded."PRODUCT_DESC" or
		bl_dm.dim_products."PRODUCT_TYPE_ID" is distinct  from excluded."PRODUCT_TYPE_ID" or
		bl_dm.dim_products."PRODUCT_TYPE_DESC" is distinct  from excluded."PRODUCT_TYPE_DESC" or
		bl_dm.dim_products."PRODUCT_CATEGORY_ID" is distinct  from excluded."PRODUCT_CATEGORY_ID" or
		bl_dm.dim_products."PRODUCT_CATEGORY_DESC" is distinct  from excluded."PRODUCT_CATEGORY_DESC" or
		bl_dm.dim_products."PRODUCT_GROUP_ID" is distinct  from excluded."PRODUCT_GROUP_ID" or
		bl_dm.dim_products."PRODUCT_GROUP_DESC" is distinct  from excluded."PRODUCT_GROUP_DESC" or
		bl_dm.dim_products."PROMO_FLAG" is distinct  from excluded."PROMO_FLAG" or
		bl_dm.dim_products."PROMO_DISCOUNT" is distinct  from excluded."PROMO_DISCOUNT" or
		bl_dm.dim_products."BASE_PRICE" is distinct  from excluded."BASE_PRICE" or
		bl_dm.dim_products."IS_LIMITED_EDITION" is distinct  from excluded."IS_LIMITED_EDITION" ;

        GET DIAGNOSTICS v_rows = ROW_COUNT;
        rows_inserted := rows_inserted + v_rows;
    END LOOP;
    CALL bl_cl.log_etl_dm('LOAD_DIM_PRODUCTS', rows_inserted, 'SUCCESS');

EXCEPTION WHEN OTHERS THEN
    CALL bl_cl.log_etl_dm('LOAD_DIM_PRODUCTS', 0, 'ERROR: ' || SQLERRM);
    RAISE;
END;
$$;


--LOAD_DIM_STAFF
CREATE OR REPLACE PROCEDURE bl_cl.load_dim_staff()
LANGUAGE plpgsql
AS $$
DECLARE  rows_inserted INT := 0;
BEGIN
    INSERT INTO bl_dm.dim_staff (
        "STAFF_SURR_ID",
        "STAFF_SOURCE_ID",
        "STAFF_FIRST_NAME",
        "STAFF_LAST_NAME",
        "JOB_START_DT",
        "EMPLOYMENT_STATUS",
        "HOURLY_WAGE",
        "JOB_ID",
        "JOB_DESC",
        "TA_INSERT_DT",
        "TA_UPDATE_DT",
        "SOURCE_SYSTEM",
        "SOURCE_ENTITY"
    )
    SELECT  nextval('bl_dm.dim_staff_seq'),
        st."STAFF_ID",
        st."STAFF_FIRST_NAME",
        st."STAFF_LAST_NAME",
        st."JOB_START_DT",
        st."EMPLOYMENT_STATUS",
        st."HOURLY_WAGE",
        j."JOB_ID",
        j."JOB_DESC",
        CURRENT_TIMESTAMP,
        CURRENT_TIMESTAMP,
        'BL_3NF',
        'CE_STAFF'
    FROM bl_3nf.ce_staff_jobs sj
    JOIN bl_3nf.ce_staff st ON sj."STAFF_ID" = st."STAFF_ID"
    JOIN bl_3nf.ce_jobs j ON sj."JOB_ID" = j."JOB_ID"
    on conflict("STAFF_SOURCE_ID","SOURCE_SYSTEM","SOURCE_ENTITY")
	do update set 
        "STAFF_FIRST_NAME"=excluded."STAFF_FIRST_NAME",
        "STAFF_LAST_NAME"=excluded. "STAFF_LAST_NAME",
        "JOB_START_DT"=excluded."JOB_START_DT",
        "EMPLOYMENT_STATUS"=excluded."EMPLOYMENT_STATUS",
        "HOURLY_WAGE"=excluded. "HOURLY_WAGE",
        "JOB_ID"=excluded."JOB_ID",
        "JOB_DESC"=excluded."JOB_DESC",
        "TA_UPDATE_DT"=current_timestamp
	where 
	   bl_dm.dim_staff."STAFF_FIRST_NAME" is distinct from excluded."STAFF_FIRST_NAME" or
        bl_dm.dim_staff."STAFF_LAST_NAME" is distinct from excluded. "STAFF_LAST_NAME" or
        bl_dm.dim_staff."JOB_START_DT" is distinct from excluded."JOB_START_DT" or
        bl_dm.dim_staff."EMPLOYMENT_STATUS" is distinct from excluded."EMPLOYMENT_STATUS" or
        bl_dm.dim_staff."HOURLY_WAGE" is distinct from excluded."HOURLY_WAGE" or
        bl_dm.dim_staff."JOB_ID" is distinct from excluded."JOB_ID" or
        bl_dm.dim_staff."JOB_DESC" is distinct from excluded."JOB_DESC";

    GET DIAGNOSTICS rows_inserted = ROW_COUNT;
    CALL bl_cl.log_etl_dm('LOAD_DIM_STAFF', rows_inserted, 'SUCCESS');

EXCEPTION WHEN OTHERS THEN  
CALL bl_cl.log_etl_dm('LOAD_DIM_STAFF', 0, 'ERROR: ' || SQLERRM);
    RAISE;
END;
$$;



--dim payments
CREATE OR REPLACE PROCEDURE bl_cl.load_dim_payments()
LANGUAGE plpgsql
AS $$
DECLARE
    rec payment_composite_type;  -- Composite type variable
    rows_affected INT := 0;
	  rows_inserted INT := 0;
    sql_stmt TEXT;
	
BEGIN
    FOR rec IN 
        SELECT 
            p."PAYMENT_ID" AS "PAYMENT_SOURCE_ID",
            p."PAYMENT_METHOD_ID" AS "PAYMENT_METHOD_ID",
            m."PAYMENT_METHOD_DESC" AS "PAYMENT_METHOD_DESC",
            p."PAYMENT_PROVIDER_ID" AS "PAYMENT_PROVIDER_ID",
            pr."PAYMENT_PROVIDER_DESC" AS "PAYMENT_PROVIDER_DESC",
            p."TRANSACTION_FEE" AS "TRANSACTION_FEE",
            CURRENT_TIMESTAMP AS "TA_INSERT_DT",
            CURRENT_TIMESTAMP AS "TA_UPDATE_DT",
            'BL_3NF' AS "SOURCE_SYSTEM",
            'CE_PAYMENTS' AS "SOURCE_ENTITY"
        FROM bl_3nf.ce_payments p
        LEFT JOIN bl_3nf.ce_payment_methods m ON p."PAYMENT_METHOD_ID" = m."PAYMENT_METHOD_ID"
        LEFT JOIN bl_3nf.ce_payment_providers pr ON p."PAYMENT_PROVIDER_ID" = pr."PAYMENT_PROVIDER_ID"
    LOOP
        sql_stmt := 'INSERT INTO bl_dm.dim_payments (
                        "PAYMENT_SURR_ID",
                        "PAYMENT_SOURCE_ID",
                        "PAYMENT_METHOD_ID",
                        "PAYMENT_METHOD_DESC",
                        "PAYMENT_PROVIDER_ID",
                        "PAYMENT_PROVIDER_DESC",
                        "TRANSACTION_FEE",
                        "TA_INSERT_DT",
                        "TA_UPDATE_DT",
                        "SOURCE_SYSTEM",
                        "SOURCE_ENTITY")
                    VALUES (  NEXTVAL(''bl_dm.dim_payments_seq''),
                        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
                    ON CONFLICT ("PAYMENT_SOURCE_ID","SOURCE_ENTITY","SOURCE_SYSTEM") DO NOTHING';

        EXECUTE sql_stmt
        USING
            rec."PAYMENT_SOURCE_ID",
            rec."PAYMENT_METHOD_ID",
            rec."PAYMENT_METHOD_DESC",
            rec."PAYMENT_PROVIDER_ID",
            rec."PAYMENT_PROVIDER_DESC",
            rec."TRANSACTION_FEE",
            rec."TA_INSERT_DT",
            rec."TA_UPDATE_DT",
            rec."SOURCE_SYSTEM",
            rec."SOURCE_ENTITY";
	    GET DIAGNOSTICS rows_inserted = ROW_COUNT;
        rows_affected := rows_affected + rows_inserted;
    END LOOP;
    CALL bl_cl.log_etl_dm('LOAD_DIM_PAYMENTS', rows_affected, 'success');

EXCEPTION WHEN OTHERS THEN
    CALL bl_cl.log_etl_dm('LOAD_DIM_PAYMENTS', 0, 'ERROR: ' || SQLERRM);
    RAISE;
END;
$$;

--LOAD_DIM_DATES
CREATE OR REPLACE PROCEDURE BL_cl.LOAD_DIM_DATES()
LANGUAGE plpgsql
AS $$
DECLARE
    rows_inserted INT := 0;
BEGIN
    WITH DATE_RANGES AS (  SELECT DT::DATE AS FULL_DATE
        FROM GENERATE_SERIES('2022-01-01'::DATE, '2027-02-01'::DATE, INTERVAL '1 DAY') AS DT
    )
    INSERT INTO BL_DM.DIM_DATES (
        "DATE_ID",
        "DAY_OF_WEEK",
        "DAY_OF_MONTH",
        "WEEK_ID",
        "MONTH_ID",
        "MONTH_DESC",
        "QUARTER_ID",
        "QUARTER_DESC",
        "YEAR_ID",
        "IS_WEEKEND")
    SELECT 
        TO_CHAR(D.FULL_DATE,'YYYYMMDD')::BIGINT AS "DATE_ID",
        TRIM(TO_CHAR(D.FULL_DATE,'DAY')) AS "DAY_OF_WEEK",
        EXTRACT(DAY FROM D.FULL_DATE)::INT AS "DAY_OF_MONTH",
        (EXTRACT(YEAR FROM D.FULL_DATE)::INT * 100 + EXTRACT(WEEK FROM D.FULL_DATE)::INT)::BIGINT AS "WEEK_ID",
        (EXTRACT(YEAR FROM D.FULL_DATE)::INT * 100 + EXTRACT(MONTH FROM D.FULL_DATE)::INT)::BIGINT AS "MONTH_ID",
        TRIM(TO_CHAR(D.FULL_DATE,'MONTH')) AS "MONTH_DESC",
        EXTRACT(QUARTER FROM D.FULL_DATE)::INT AS "QUARTER_ID",
        'Q' || EXTRACT(QUARTER FROM D.FULL_DATE)::TEXT AS "QUARTER_DESC",
        EXTRACT(YEAR FROM D.FULL_DATE)::BIGINT AS "YEAR_ID",
        CASE WHEN EXTRACT(DOW FROM D.FULL_DATE) IN (0,6) THEN TRUE ELSE FALSE END AS "IS_WEEKEND"
    FROM DATE_RANGES D
    WHERE NOT EXISTS (  SELECT 1 FROM BL_DM.DIM_DATES dd WHERE dd."DATE_ID" = TO_CHAR(D.FULL_DATE,'YYYYMMDD')::BIGINT )
    ORDER BY "DATE_ID";

    GET DIAGNOSTICS rows_inserted = ROW_COUNT;

    CALL BL_CL.LOG_ETL_DM('LOAD_DIM_DATES', rows_inserted, 'SUCCESS');

EXCEPTION WHEN OTHERS THEN  CALL BL_CL.LOG_ETL_DM('LOAD_DIM_DATES', 0, 'ERROR: ' || SQLERRM);
    RAISE;
END;
$$;


--LOAD_DIM_STORES

CREATE OR REPLACE PROCEDURE bl_cl.load_dim_stores()
LANGUAGE plpgsql
AS $$
DECLARE
    rows_processed INT := 0;
    rows_affected INT := 0;
    v_rowcount INT;
    rec RECORD;
BEGIN  FOR rec IN  SELECT
            s."STORE_ID",
            s."STORE_DESC",
            s."WEBSITE",
            c."CITY_ID",
            c."CITY_DESC",
            co."COUNTRY_ID",
            co."COUNTRY_DESC",
            s."STORE_ADDRESS",
            s."STORE_TYPE",
            s."TA_INSERT_DT",
            CURRENT_TIMESTAMP AS "TA_UPDATE_DT",
            'BL_3NF' AS "SOURCE_SYSTEM",
            'CE_STORES' AS "SOURCE_ENTITY"
        FROM bl_3nf.ce_stores s
        JOIN bl_3nf.ce_cities c ON s."CITY_ID" = c."CITY_ID"
        JOIN bl_3nf.ce_countries co ON c."COUNTRY_ID" = co."COUNTRY_ID"
    LOOP
        INSERT INTO bl_dm.dim_stores (
            "STORE_SURR_ID",
            "STORE_SOURCE_ID",
            "STORE_DESC",
            "WEBSITE",
            "CITY_ID",
            "CITY_DESC",
            "COUNTRY_ID",
            "COUNTRY_DESC",
            "STORE_ADDRESS",
            "STORE_TYPE",
            "TA_INSERT_DT",
            "TA_UPDATE_DT",
            "SOURCE_SYSTEM",
            "SOURCE_ENTITY"
        )
        VALUES (
            nextval('bl_dm.dim_stores_seq'),
            rec."STORE_ID",
            rec."STORE_DESC",
            rec."WEBSITE",
            rec."CITY_ID",
            rec."CITY_DESC",
            rec."COUNTRY_ID",
            rec."COUNTRY_DESC",
            rec."STORE_ADDRESS",
            rec."STORE_TYPE",
            rec."TA_INSERT_DT",
            rec."TA_UPDATE_DT",
            rec."SOURCE_SYSTEM",
            rec."SOURCE_ENTITY"
        )
        ON CONFLICT ("STORE_SOURCE_ID", "SOURCE_SYSTEM", "SOURCE_ENTITY")
        DO update set 
						"CITY_ID"=excluded."CITY_ID",
						"WEBSITE"=excluded."WEBSITE",
						"STORE_DESC"=excluded."STORE_DESC",
						"STORE_ADDRESS"=excluded."STORE_ADDRESS",
						"CITY_DESC"=excluded."CITY_DESC",
						"COUNTRY_ID"=excluded."COUNTRY_ID",
            			"COUNTRY_DESC"=excluded."COUNTRY_DESC",
						"STORE_TYPE"=excluded."STORE_TYPE",
						"TA_UPDATE_DT"=current_timestamp

				  where  
						bl_dm.dim_stores."CITY_ID" is distinct from excluded."CITY_ID" or
						bl_dm.dim_stores."WEBSITE" is distinct from excluded."WEBSITE" or
						bl_dm.dim_stores."STORE_DESC" is distinct from excluded."STORE_DESC" or
						bl_dm.dim_stores."STORE_ADDRESS" is distinct from excluded."STORE_ADDRESS" or
						bl_dm.dim_stores."CITY_DESC" is distinct from excluded."CITY_DESC" or
						bl_dm.dim_stores."COUNTRY_ID" is distinct from excluded."COUNTRY_ID" or
						bl_dm.dim_stores."COUNTRY_DESC" is distinct from excluded."COUNTRY_DESC" or
						bl_dm.dim_stores."STORE_TYPE" is distinct from excluded."STORE_TYPE" ;

        GET DIAGNOSTICS v_rowcount = ROW_COUNT;
        rows_affected := rows_affected + v_rowcount;
        rows_processed := rows_processed ;
    END LOOP;

    CALL bl_cl.log_etl_dm('LOAD_DIM_STORES', rows_affected, 'success');

EXCEPTION WHEN OTHERS THEN
    CALL bl_cl.log_etl_dm('LOAD_DIM_STORES', 0, 'ERROR: ' || SQLERRM);
    RAISE;
END;
$$;

--LOAD_DIM_CUSTOMERS_SCD
CREATE OR REPLACE PROCEDURE bl_cl.load_dim_customers_scd()
LANGUAGE plpgsql
AS $$
DECLARE
    rows_inserted INT := 0;
BEGIN
     MERGE INTO bl_dm.dim_customers_scd tgt
 USING (SELECT cust.*,
 			   c."COUNTRY_DESC"
 			   FROM bl_3nf.ce_customers_scd cust
 			   LEFT JOIN bl_3nf.ce_countries c
 			   ON cust."COUNTRY_ID"=c."COUNTRY_ID") src
			   ON tgt."CUSTOMER_FIRST_NAME"=src."CUSTOMER_FIRST_NAME"
			 AND tgt."CUSTOMER_SOURCE_ID"=src."CUSTOMER_ID"
			 AND tgt."CUSTOMER_LAST_NAME"=src."CUSTOMER_LAST_NAME"
			 AND tgt."COUNTRY_ID"=src."COUNTRY_ID"
			 AND tgt."LOYALTY_MEMBER"=src."LOYALTY_MEMBER"
			 AND tgt."LOYALTY_DISCOUNT"=src."LOYALTY_DISCOUNT"
			 AND tgt. "GENDER"=src."GENDER"
			 AND tgt."BIRTH_YEAR"=src."BIRTH_YEAR"
			 AND tgt."SIGNUP_DT"=src."SIGNUP_DT"
 
WHEN MATCHED AND src."IS_ACTIVE"=FALSE AND tgt."IS_ACTIVE"=TRUE THEN
UPDATE SET "IS_ACTIVE"=FALSE,
 		   "END_DT"=current_timestamp,
       "TA_UPDATE_DT"=current_timestamp
WHEN NOT MATCHED and src."IS_ACTIVE"=TRUE then
INSERT ("CUSTOMER_SURR_ID",
        "CUSTOMER_SOURCE_ID",
        "CUSTOMER_FIRST_NAME",
        "CUSTOMER_LAST_NAME",
        "COUNTRY_ID",
        "COUNTRY_DESC",
        "LOYALTY_MEMBER",
        "LOYALTY_DISCOUNT",
        "GENDER",
        "BIRTH_YEAR",
        "SIGNUP_DT",
        "START_DT",
        "END_DT",
        "IS_ACTIVE",
        "TA_INSERT_DT",
        "TA_UPDATE_DT",
        "SOURCE_SYSTEM",
        "SOURCE_ENTITY")
        VALUES ( nextval('bl_dm.dim_customers_scd_seq'),
        src."CUSTOMER_ID",
        src."CUSTOMER_FIRST_NAME",
        src."CUSTOMER_LAST_NAME",
        src."COUNTRY_ID",
        src."COUNTRY_DESC",
        src."LOYALTY_MEMBER",
        src."LOYALTY_DISCOUNT",
        src."GENDER",
        src."BIRTH_YEAR",
        src."SIGNUP_DT",
        src."START_DT",
        src."END_DT",
        src."IS_ACTIVE",
        CURRENT_TIMESTAMP,
        CURRENT_TIMESTAMP,
        'BL_3NF',
        'CE_CUSTOMERS_SCD');
    GET DIAGNOSTICS rows_inserted = ROW_COUNT;

    CALL bl_cl.log_etl_dm('LOAD_DIM_CUSTOMERS_SCD', rows_inserted, 'SUCCESS');

EXCEPTION WHEN OTHERS THEN  CALL bl_cl.log_etl_dm('LOAD_DIM_CUSTOMERS_SCD', 0, 'ERROR: ' || SQLERRM);
    RAISE;
END;
$$;



--LOAD FACt TABLE
CREATE OR REPLACE PROCEDURE BL_CL.LOAD_FCT_SALES_DD()
LANGUAGE plpgsql
AS $$
DECLARE
    rows_inserted INT := 0;
    archive_cutoff_dt INT := TO_CHAR((CURRENT_DATE - INTERVAL '3 months')::DATE, 'YYYYMM01')::INT;
    current_month_start DATE := DATE_TRUNC('month', CURRENT_DATE);
    next_month_start DATE := current_month_start + INTERVAL '1 month';
    month_start DATE;
    part_name TEXT;
    part_start INT;
    part_end INT;
BEGIN
    -- creating archive partition for data older than 3 months
    BEGIN EXECUTE format('CREATE TABLE IF NOT EXISTS bl_dm.fct_sales_dd_archive  PARTITION OF bl_dm.fct_sales_dd   FOR VALUES FROM (MINVALUE) TO (%L)', archive_cutoff_dt);
        -- Update constraint to ensure only old data goes here
        EXECUTE format('ALTER TABLE bl_dm.fct_sales_dd_archive  DROP CONSTRAINT IF EXISTS fct_sales_dd_archive_event_dt_check');
        EXECUTE format('ALTER TABLE bl_dm.fct_sales_dd_archive ADD CONSTRAINT fct_sales_dd_archive_event_dt_check CHECK ("EVENT_DT" < %L)', archive_cutoff_dt);
    EXCEPTION WHEN OTHERS THEN  CALL BL_CL.LOG_ETL('LOAD_FCT_SALES_DD', 0, 'Archive partition error: ' || SQLERRM);
    END;
    -- creating monthly partitions for rolling window(3 months back to 1 month forward)
    month_start := DATE_TRUNC('month',CURRENT_DATE -INTERVAL '3 months');
    WHILE month_start <= next_month_start 
    LOOP
        part_name := 'fct_sales_dd_' || TO_CHAR(month_start, 'YYYYMM');
        part_start := TO_CHAR(month_start, 'YYYYMMDD')::INT;
        part_end := TO_CHAR(month_start + INTERVAL '1 month', 'YYYYMMDD')::INT;
        BEGIN
            -- only creating partition if it doesn't exist
            IF NOT EXISTS (  SELECT 1 FROM pg_class c JOIN pg_namespace n ON c.relnamespace = n.oid WHERE n.nspname = 'bl_dm' AND c.relname = part_name) THEN
                
            EXECUTE format('CREATE TABLE if not exists bl_dm.%I PARTITION OF bl_dm.fct_sales_dd   FOR VALUES FROM (%L) TO (%L)',  part_name, part_start, part_end);
            END IF;
        EXCEPTION WHEN OTHERS THEN  CALL BL_CL.LOG_ETL('LOAD_FCT_SALES_DD', 0, 'Partition ' || part_name || ' error: ' || SQLERRM);
        END;
        month_start := month_start + INTERVAL '1 month';
    END LOOP;

    WITH prepared_data AS (
        SELECT  NEXTVAL('BL_DM.FCT_SALES_DD_SEQ') AS "SALE_SURR_ID",
            COALESCE(s."SALE_SRC_ID", 'n.a') AS "SALE_ID",
            COALESCE(s."SALE_ID", -1) AS "SALE_SOURCE_ID",
            COALESCE(c."CUSTOMER_SURR_ID", -1) AS "CUSTOMER_ID",
            COALESCE(st."STAFF_SURR_ID", -1) AS "STAFF_ID",
            COALESCE(store."STORE_SURR_ID", -1) AS "STORE_ID",
            COALESCE(pay."PAYMENT_SURR_ID", -1) AS "PAYMENT_ID",
            COALESCE(mgr."STAFF_SURR_ID", -1) AS "MANAGER_ID",
            COALESCE(p."PRODUCT_SURR_ID", -1) AS "PRODUCT_ID",
            coalesce(s."EVENT_DT",-1) as "EVENT_DT",
            s."QUANTITY",
            s."LINE_ITEM_AMOUNT",
            s."COST",
            s."PROFIT",
            s."PROFIT_MARGIN",
            s."DELIVERY_FEE",
            CURRENT_TIMESTAMP AS "TA_INSERT_DT",
            CURRENT_TIMESTAMP AS "TA_UPDATE_DT",
            'BL_3NF' AS "SOURCE_SYSTEM",
            'CE_SALES' AS "SOURCE_ENTITY"
        FROM BL_3NF.CE_SALES s
        LEFT JOIN BL_DM.DIM_CUSTOMERS_SCD c ON coalesce(s."CUSTOMER_ID",-1) =c."CUSTOMER_SOURCE_ID"
        LEFT JOIN BL_DM.DIM_STAFF st ON coalesce(s."STAFF_ID",-1) = st."STAFF_SOURCE_ID"
        LEFT JOIN BL_DM.DIM_STORES store ON coalesce(s."STORE_ID",-1) = store."STORE_SOURCE_ID"
        LEFT JOIN BL_DM.DIM_STAFF mgr ON coalesce(s."MANAGER_ID",-1) =mgr."STAFF_SOURCE_ID"
        LEFT JOIN BL_DM.DIM_PRODUCTS p ON coalesce(s."PRODUCT_ID",-1) =p."PRODUCT_SOURCE_ID"
        LEFT JOIN BL_DM.DIM_PAYMENTS pay ON coalesce(s."PAYMENT_ID",-1) = pay."PAYMENT_SOURCE_ID")
    INSERT INTO bl_dm.fct_sales_dd("SALE_SURR_ID",
									"SALE_ID" ,
									"SALE_SOURCE_ID" ,
									"CUSTOMER_ID",
									"STAFF_ID",
									"STORE_ID",
									"PAYMENT_ID",
									"MANAGER_ID",
									"PRODUCT_ID",
									"EVENT_DT",
									"QUANTITY",
									"LINE_ITEM_AMOUNT" ,
									"COST" ,
									"PROFIT" ,
									"PROFIT_MARGIN" ,
									"DELIVERY_FEE" ,
									"TA_INSERT_DT",
									"TA_UPDATE_DT",
									"SOURCE_SYSTEM" ,
									"SOURCE_ENTITY" )
    SELECT "SALE_SURR_ID",
			"SALE_ID" ,
			"SALE_SOURCE_ID" ,
			"CUSTOMER_ID",
			"STAFF_ID",
			"STORE_ID",
			"PAYMENT_ID",
			"MANAGER_ID",
			"PRODUCT_ID",
			"EVENT_DT",
			"QUANTITY",
			"LINE_ITEM_AMOUNT",
			"COST",
			"PROFIT" ,
			"PROFIT_MARGIN" ,
			"DELIVERY_FEE" ,
			"TA_INSERT_DT",
			"TA_UPDATE_DT",
			"SOURCE_SYSTEM" ,
			"SOURCE_ENTITY" 
FROM prepared_data
    ON CONFLICT ("EVENT_DT", "SALE_SOURCE_ID", "SOURCE_SYSTEM", "SOURCE_ENTITY") 
    DO NOTHING;
	 GET DIAGNOSTICS rows_inserted = ROW_COUNT;
    CALL BL_CL.LOG_ETL_DM('LOAD_FCT_SALES_DD', rows_inserted, 'SUCCESS: Loaded data into correct partitions');
    
EXCEPTION WHEN OTHERS THEN CALL BL_CL.LOG_ETL_DM('LOAD_FCT_SALES_DD', 0, 'ERROR: ' || SQLERRM);
RAISE;
END;
$$;


--MASTER_PROCEDURE
CREATE OR REPLACE PROCEDURE bl_cl.master_procedure()
LANGUAGE plpgsql
AS $$
BEGIN
    CALL bl_cl.load_ce_countries();
    CALL bl_cl.load_ce_cities();
    CALL bl_cl.load_ce_customers_scd();         
    CALL bl_cl.load_ce_jobs();
	CALL bl_cl.load_ce_staff();
    CALL bl_cl.load_ce_payment_methods();
    CALL bl_cl.load_ce_payment_providers();
    CALL bl_cl.load_ce_payments();
    CALL bl_cl.load_ce_product_groups();
	CALL bl_cl.load_ce_product_categories();
    CALL bl_cl.load_ce_product_types();
    CALL bl_cl.load_ce_products();
	CALL bl_cl.load_ce_stores();
    CALL bl_cl.load_ce_staff_jobs();
    CALL bl_cl.load_ce_staff_stores();
 	CALL bl_cl.load_ce_sales();

    CALL bl_cl.load_dim_customers_scd();        
    CALL bl_cl.load_dim_dates();
    CALL bl_cl.load_dim_payments();
    CALL bl_cl.load_dim_products();
    CALL bl_cl.load_dim_staff();
    CALL bl_cl.load_dim_stores();
	CALL bl_cl.load_fct_sales_dd();
 
END;
$$;


CALL bl_cl.master_procedure();
SELECT * FROM BL_CL.ETL_LOG_DM ORDER BY log_time DESC;
SELECT * FROM BL_CL.ETL_LOG ORDER BY log_time DESC;
SELECT * FROM bl_cl.load_tracker;

SELECT 'fct_sales_dd_archive' AS partition, COUNT(*) AS row_count FROM bl_dm.fct_sales_dd_archive
UNION ALL
SELECT 'fct_sales_dd_202504', COUNT(*) FROM bl_dm.fct_sales_dd_202504
UNION ALL
SELECT 'fct_sales_dd_202505', COUNT(*) FROM bl_dm.fct_sales_dd_202505
UNION ALL
SELECT 'fct_sales_dd_202506', COUNT(*) FROM bl_dm.fct_sales_dd_202506
UNION ALL
SELECT 'fct_sales_dd_202507', COUNT(*) FROM bl_dm.fct_sales_dd_202507
UNION ALL
SELECT 'fct_sales_dd_202508', COUNT(*) FROM bl_dm.fct_sales_dd_202508;



--DUPLICATE_CHECKS
select cnt."COUNTRY_SRC_ID",COUNT(*) from BL_3NF.CE_COUNTRIES cnt
group by cnt."COUNTRY_SRC_ID",cnt."SOURCE_SYSTEM",cnt."SOURCE_ENTITY"
HAVING COUNT(*)>1;
----
select ct."CITY_SRC_ID",COUNT(*) from BL_3NF.CE_CITIES ct
group by ct."CITY_SRC_ID",ct."SOURCE_SYSTEM",ct."SOURCE_ENTITY"
HAVING COUNT(*)>1;
--
select gp."PRODUCT_GROUP_SRC_ID",COUNT(*) from BL_3NF.CE_PRODUCT_GROUPS gp
group by gp."PRODUCT_GROUP_SRC_ID",gp."SOURCE_SYSTEM",gp."SOURCE_ENTITY"
HAVING COUNT(*)>1;

select count(*) from bl_3nf.ce_sales;
select count(*) from bl_dm.fct_sales_dd;

--
--select gp."PRODUCT_CATEGORY_SRC_ID",COUNT(*) from BL_3NF.CE_PRODUCT_CATEGORIES gp
--group by gp."PRODUCT_CATEGORY_SRC_ID",gp."SOURCE_SYSTEM",gp."SOURCE_ENTITY"
--HAVING COUNT(*)>1;
--
--select gp."PRODUCT_TYPE_SRC_ID",COUNT(*) from BL_3NF.CE_PRODUCT_TYPES gp
--group by gp."PRODUCT_TYPE_SRC_ID",gp."SOURCE_SYSTEM",gp."SOURCE_ENTITY"
--HAVING COUNT(*)>1;
--
--select P."PRODUCT_SRC_ID",COUNT(*) from BL_3NF.CE_PRODUCTS p
--group by p."PRODUCT_SRC_ID",p."SOURCE_SYSTEM",p."SOURCE_ENTITY"
--HAVING COUNT(*)>1;
--
--select P."PRODUCT_SOURCE_ID",COUNT(*) from BL_DM.DIM_PRODUCTS p
--group by p."PRODUCT_SOURCE_ID",p."SOURCE_SYSTEM",p."SOURCE_ENTITY"
--HAVING COUNT(*)>1;
--
--select P."STAFF_SRC_ID",COUNT(*) from BL_3NF.CE_STAFF p
--group by p."STAFF_SRC_ID",p."SOURCE_SYSTEM",p."SOURCE_ENTITY"
--HAVING COUNT(*)>1;
--
--select P."STAFF_SOURCE_ID",COUNT(*) from BL_DM.DIM_STAFF p
--group by p."STAFF_SOURCE_ID",p."SOURCE_SYSTEM",p."SOURCE_ENTITY"
--HAVING COUNT(*)>1;
--
--select P."STORE_SRC_ID",COUNT(*) from BL_3NF.CE_STORES p
--group by p."STORE_SRC_ID",p."SOURCE_SYSTEM",p."SOURCE_ENTITY"
--HAVING COUNT(*)>1;
--
--select P."STORE_SOURCE_ID",COUNT(*) from BL_DM.DIM_STORES p
--group by p."STORE_SOURCE_ID",p."SOURCE_SYSTEM",p."SOURCE_ENTITY"
--HAVING COUNT(*)>1;
--
--select P."JOB_SRC_ID",COUNT(*) from BL_3NF.CE_JOBS p
--group by p."JOB_SRC_ID",p."SOURCE_SYSTEM",p."SOURCE_ENTITY"
--HAVING COUNT(*)>1;
--
--select P."PAYMENT_SRC_ID",COUNT(*) from BL_3NF.CE_PAYMENTS p
--group by p."PAYMENT_SRC_ID",p."SOURCE_SYSTEM",p."SOURCE_ENTITY"
--HAVING COUNT(*)>1;
--
--select P."PAYMENT_SOURCE_ID",COUNT(*) from BL_DM.DIM_PAYMENTS p
--group by p."PAYMENT_SOURCE_ID",p."SOURCE_SYSTEM",p."SOURCE_ENTITY"
--HAVING COUNT(*)>1;
--
--select P."PAYMENT_METHOD_SRC_ID",COUNT(*) from BL_3NF.CE_PAYMENT_METHODS p
--group by p."PAYMENT_METHOD_SRC_ID",p."SOURCE_SYSTEM",p."SOURCE_ENTITY"
--HAVING COUNT(*)>1;
--
--select P."PAYMENT_PROVIDER_SRC_ID",COUNT(*) from BL_3NF.CE_PAYMENT_PROVIDERS p
--group by p."PAYMENT_PROVIDER_SRC_ID",p."SOURCE_SYSTEM",p."SOURCE_ENTITY"
--HAVING COUNT(*)>1;
--
--select P."STAFF_JOB_SRC_ID",COUNT(*) from BL_3NF.CE_STAFF_JOBS p
--group by p."STAFF_JOB_SRC_ID",p."SOURCE_SYSTEM",p."SOURCE_ENTITY"
--HAVING COUNT(*)>1;
--
--select P."STAFF_STORE_SRC_ID",COUNT(*) from BL_3NF.CE_STAFF_STORES p
--group by p."STAFF_STORE_SRC_ID",p."SOURCE_SYSTEM",p."SOURCE_ENTITY"
--HAVING COUNT(*)>1;
--
--
--select P."SALE_SRC_ID",COUNT(*) from BL_3NF.CE_SALES p
--group by p."SALE_SRC_ID"
--HAVING COUNT(*)>1;
--
--select P."SALE_SOURCE_ID",COUNT(*) from BL_DM.FCT_SALES_DD p
--group by p."SALE_SOURCE_ID"
--HAVING COUNT(*)>1;
--



--dup check for dim_customers
SELECT c."CUSTOMER_SRC_ID",count(*) 
FROM bl_dm.dim_customers_scd d
JOIN bl_3nf.ce_customers_scd c 
ON d."CUSTOMER_SOURCE_ID"=c."CUSTOMER_ID"
WHERE d."IS_ACTIVE"=true  
GROUP BY c."CUSTOMER_SRC_ID"
HAVING count(*)>1;

----3nf scd duplicate checks
SELECT "CUSTOMER_SRC_ID", COUNT(*) as current_count
FROM bl_3nf.ce_customers_scd
WHERE "IS_ACTIVE"= TRUE
GROUP BY "CUSTOMER_SRC_ID"
HAVING COUNT(*) > 1;



--scd2 check
SELECT * FROM bl_3nf.ce_customers_scd where "CUSTOMER_SRC_ID"=637;--changed info

SELECT d.*
FROM bl_dm.dim_customers_scd d
JOIN bl_3nf.ce_customers_scd c 
ON d."CUSTOMER_SOURCE_ID"=c."CUSTOMER_ID"
WHERE "CUSTOMER_SRC_ID" =637;
--
--
SELECT * FROM bl_3nf.ce_customers_scd where "CUSTOMER_SRC_ID"=15001;

--new customer
SELECT d.*
FROM bl_dm.dim_customers_scd d
JOIN bl_3nf.ce_customers_scd c 
ON d."CUSTOMER_SOURCE_ID"=c."CUSTOMER_ID"
WHERE "CUSTOMER_SRC_ID" =15001;




